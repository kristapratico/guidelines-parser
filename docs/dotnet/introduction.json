[
  {
    "id": "dotnet-general-follow-framework-guidelines",
    "category": "General Guidelines {#dotnet-general}",
    "text": "DO follow the official .NET Framework Design Guidelines (https://aka.ms/fxdg3)  At the end of this document, you can find a section with the most commonly overlooked guidelines in existing Azure SDK libraries."
  },
  {
    "id": "dotnet-general-follow-general-guidelines",
    "category": "General Guidelines {#dotnet-general}",
    "text": "DO follow the [General Azure SDK Guidelines][general-guidelines]. The guidelines provide a robust methodology for communicating with Azure services. The easiest way to ensure that your component meets these requirements is to use the [Azure.Core] package to call Azure services. Details of these helper APIs and their usage are described in the Using HttpPipeline section."
  },
  {
    "id": "dotnet-general-use-http-pipeline",
    "category": "General Guidelines {#dotnet-general}",
    "text": "DO use HttpPipeline to implement all methods that call Azure REST services. The pipeline can be found in the [Azure.Core] package, and it takes care of many [General Azure SDK Guidelines][general-guidelines]. Details of the pipeline design and usage are described in section Using HttpPipeline below. If you can't use the pipeline, you must implement [all the general requirements of Azure SDK]({{ \"/general_azurecore.html\" | relative_url }}) manually. This document contains guidelines developed primarily for typical Azure REST services, i.e. stateless services with request-response based interaction model. Many of the guidelines in this document are more broadly applicable, but some might be specific to such REST services. Azure services are exposed to .NET developers as one or more service client types and a set of supporting types. The supporting types may include various subclients, which give structure to the API by organizing groups of related service operations, and model types, which represent resources on the service. Service clients are the main starting points for developers calling Azure services with the Azure SDK. Each client library should have at least one client in its main namespace, so it's easy to discover. The guidelines in this section describe patterns for the design of a service client. A service client should have the same shape as this code snippet: ```csharp namespace Azure.&lt;group&gt;.&lt;service_name&gt; {   // main service client class   public class &lt;service_name&gt;Client {     // simple constructors; don't use default parameters     public &lt;service_name&gt;Client(&lt;simple_binding_parameters&gt;);     public &lt;service_name&gt;Client(&lt;simple_binding_parameters&gt;, &lt;service_name&gt;ClientOptions options);     // 0 or more advanced constructors     public &lt;service_name&gt;Client(&lt;advanced_binding_parameters&gt;, &lt;service_name&gt;ClientOptions options = default);     // mocking constructor     protected &lt;service_name&gt;Client();     // service methods (synchronous and asynchronous)     public virtual Task&lt;Response&lt;&lt;model&gt;&gt; &lt;service_operation&gt;Async(&lt;parameters&gt;, CancellationToken cancellationToken = default);     public virtual Response&lt;model&gt; &lt;service_operation&gt;(&lt;parameters&gt;, CancellationToken cancellationToken = default);     // other members   }   // options for configuring the client   public class &lt;service_name&gt;ClientOptions : ClientOptions {   } } ``` For example, the Application Configuration Service client looks like this code snippet: ```csharp namespace Azure.Data.Configuration {   public class ConfigurationClient {     public ConfigurationClient(string connectionString);     public ConfigurationClient(string connectionString, ConfigurationClientOptions options);     protected ConfigurationClient(); // for mocking     public virtual Task&lt;Response&lt;&lt;ConfigurationSetting&gt;&gt; GetConfigurationSettingAsync(string key, CancellationToken cancellationToken = default);     public virtual Response&lt;ConfigurationSetting&gt; GetConfigurationSetting(string key, CancellationToken cancellationToken = default);     // other members     \u2026   }   // options for configuring the client   public class ConfigurationClientOptions : ClientOptions {     ...   } } ``` You can find the full sources of here (https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/appconfiguration/Azure.Data.AppConfiguration/src/ConfigurationClient.cs) "
  },
  {
    "id": "dotnet-client-naming",
    "category": "The Service Client {#dotnet-client}",
    "text": "DO name service client types with the Client suffix. For example, the service client for the Application Configuration service is called ConfigurationClient."
  },
  {
    "id": "dotnet-client-location",
    "category": "The Service Client {#dotnet-client}",
    "text": "DO place at least one service client in the root namespace of their corresponding component."
  },
  {
    "id": "dotnet-client-type",
    "category": "The Service Client {#dotnet-client}",
    "text": "DO make service clients classes (reference types), not structs (value types)."
  },
  {
    "id": "dotnet-client-immutable",
    "category": "The Service Client {#dotnet-client}",
    "text": "DO make service clients immutable. Client instances are often shared between threads (stored in application statics) and it should be difficult, if not impossible, for one of these threads to affect others."
  },
  {
    "id": "dotnet-client-namespace",
    "category": "The Service Client {#dotnet-client}",
    "text": "DO see Namespace Naming guidelines for how to choose the namespace for the client types."
  },
  {
    "id": "dotnet-client-constructor-minimal",
    "category": "Service Client Constructors {#dotnet-client-ctor}",
    "text": "DO provide a minimal constructor that takes only the parameters required to connect to the service. For example, you may use a connection string, or host name and authentication. It should be easy to start using the client without extensive customization. ```csharp public class ConfigurationClient {   public ConfigurationClient(string connectionString); } ```"
  },
  {
    "id": "dotnet-client-constructor-no-default-params",
    "category": "Service Client Constructors {#dotnet-client-ctor}",
    "text": "DO NOT use default parameters in the simplest constructor."
  },
  {
    "id": "dotnet-client-constructor-overloads",
    "category": "Service Client Constructors {#dotnet-client-ctor}",
    "text": "DO provide constructor overloads that allow specifying additional options such as credentials, a custom HTTP pipeline, or advanced configuration. Custom pipeline and client-specific configuration are represented by an options parameter. The type of the parameter is typically a subclass of ClientOptions type, shown below."
  },
  {
    "id": "dotnet-http-pipeline-options",
    "category": "Using ClientOptions {#dotnet-usage-options}",
    "text": "DO name subclasses of ClientOptions by adding Options suffix to the name of the client type the options subclass is configuring. ```csharp // options for configuring ConfigurationClient public class ConfigurationClientOptions : ClientOptions {   ... } public class ConfigurationClient {   public ConfigurationClient(string connectionString, ConfigurationClientOptions options);   ... } ``` If the options type can be shared by multiple client types, name it with a more general name, such as <library_name>ClientOptions. For example, the BlobClientOptions class can be used by BlobClient, BlobContainerClient, and BlobAccountClient."
  },
  {
    "id": "dotnet-options-no-default-constructor",
    "category": "Using ClientOptions {#dotnet-usage-options}",
    "text": "DO NOT have a default constructor on the options type. Each overload constructor should take at least version parameter to specify the service version. See Versioning guidelines for details. For example, the ConfigurationClient type and its public constructors look as follows: ```csharp public class ConfigurationClient {   public ConfigurationClient(string connectionString);   public ConfigurationClient(string connectionString, ConfigurationClientOptions options);   public ConfigurationClient(Uri uri, TokenCredential credential, ConfigurationClientOptions options = default); } ```"
  },
  {
    "id": "dotnet-versioning-highest-api",
    "category": "Service Versions {#dotnet-service-version-option}",
    "text": "DO call the highest supported service API version by default."
  },
  {
    "id": "dotnet-versioning-select-api-version",
    "category": "Service Versions {#dotnet-service-version-option}",
    "text": "DO allow the consumer to explicitly select a supported service API version when instantiating the service client. Use a constructor parameter called version on the client options type. The version parameter must be the first parameter to all constructor overloads. The version parameter must be required, and default to the latest supported service version. The type of the version parameter must be ServiceVersion; an enum nested in the options type. The ServiceVersion enum must use explicit values starting from 1. ServiceVersion enum value 0 is reserved. When 0 is passed into APIs, ArgumentException should be thrown. For example, the following is a code snippet from the ConfigurationClientOptions: ```csharp public class ConfigurationClientOptions : ClientOptions {   public ConfigurationClientOptions(ServiceVersion version = ServiceVersion.V2019_05_09) {     if (version == default)       throw new ArgumentException($\"The service version {version} is not supported by this library.\");     }   }   public enum ServiceVersion {     V2019_05_09 = 1,   }   ... } ``` {% include note.html content=\"Third-party reusable libraries shouldn't change behavior without an explicit decision by the developer. When developing libraries that are based on the Azure SDK, lock the library to a specific service version to avoid changes in behavior.\" %}"
  },
  {
    "id": "dotnet-versioning-feature-flags",
    "category": "Service Versions {#dotnet-service-version-option}",
    "text": "DO NOT force consumers to test service API versions to check support for a feature. Use the tester-doer .NET pattern to implement feature flags, or use Nullable<T>. For example, if the client library supports two service versions, only one of which can return batches, the consumer might write the following code: ```csharp if (client.CanBatch) {   Response&lt;SettingBatch&gt; response = await client.GetBatch(\"some_key*\");   Guid? Guid = response.Result.Guid; } else {   Response&lt;ConfigurationSetting&gt; response1 = await client.GetAsync(\"some_key1\");   Response&lt;ConfigurationSetting&gt; response2 = await client.GetAsync(\"some_key2\");   Response&lt;ConfigurationSetting&gt; response3 = await client.GetAsync(\"some_key3\"); } ```"
  },
  {
    "id": "dotnet-client-constructor-for-mocking",
    "category": "Mocking",
    "text": "DO provide protected parameterless constructor for mocking. ```csharp public class ConfigurationClient {   protected ConfigurationClient(); } ```"
  },
  {
    "id": "dotnet-client-constructor-use-params",
    "category": "Mocking",
    "text": "DO NOT reference virtual properties of the client class as parameters to other methods or constructors within the client constructor. This violates the [.NET Framework Constructor Design] because a field to which a virtual property refers may not be initialized yet, or a mocked virtual property may not be set up yet. Use parameters or local variables instead: ```csharp public class ConfigurationClient {   private readonly ConfigurationRestClient _client;   public ConfigurationClient(string connectionString) {     ConnectionString = connectionString;     // Use parameter below instead of the class-defined virtual property.     _client = new ConfigurationRestClient(connectionString);   }   public virtual string ConnectionString { get; } } ``` In mocks, using the virtual property instead of the parameter requires the property to be mocked to return the value before the constructor is called when the mock is created. In [Moq] this requires using the delegate parameter to create the mock, which may not be an obvious workaround. See Support for Mocking for details. There are two categories of clients: service clients and their subclients. Service clients can be instantiated and have the Client suffix. Subclients can only be created by calling factory methods on other clients (commonly on service clients) and do not have the client suffix. As discussed above, the service client is the entry point to the API for an Azure service -- from it, library users can invoke all operations the service provides and can easily implement the most common scenarios. Where it will simplify an API's design, groups of service calls can be organized around smaller subclient types."
  },
  {
    "id": "dotnet-service-client-entry-point",
    "category": "Subclients {#dotnet-subclients}",
    "text": "DO use service clients to indicate the starting point(s) for the most common customer scenarios."
  },
  {
    "id": "dotnet-use-subclients",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU SHOULD use subclients to group operations related to a service resource or functional area to improve API usability. There are a variety of types of subclients. These include: Resource Clients, which group methods bound to a specific resource, along with information about the resource. Operation Group Clients, which are not bound to a resource but group related operations. If referring to a specific resource, these would take a resource identifier as a parameter. Subclasses of Operation<T>, which manage service calls related to long running operations. Pageable<T> types returned from paging methods, which manage service calls to retrieve pages of elements in a collection. For example, in the Azure Container Registry API, a ContainerRegistryClient service client provides an entry point for communicating with the service, and a ContainerRepository resource client organizes operations related to a specific repository resource: ```C# public class ContainerRegistryClient {   // ...   public virtual ContainerRepository GetRepository(string name); }  public class ContainerRepository {   protected ContainerRepository();   public virtual string Name { get; }   public virtual Response Delete(CancellationToken cancellationToken = default);   public virtual Response&lt;ContainerRepositoryProperties&gt; GetProperties(CancellationToken cancellationToken = default);   public virtual Response&lt;ContainerRepositoryProperties&gt; UpdateProperties(ContainerRepositoryProperties value, CancellationToken cancellationToken = default);   // ... } ``` ServiceBusSender groups operations for sending messages to a specific entity with properties that identify that entity. ```C#   public class ServiceBusSender {     protected ServiceBusSender();     public virtual string EntityPath { get; }     public virtual Task CancelScheduledMessageAsync(long sequenceNumber, CancellationToken cancellationToken = default);     public virtual ValueTask&lt;ServiceBusMessageBatch&gt; CreateMessageBatchAsync(CancellationToken cancellationToken = default);     public virtual Task&lt;long&gt; ScheduleMessageAsync(ServiceBusMessage message, DateTimeOffset scheduledEnqueueTime, CancellationToken cancellationToken = default);     public virtual Task SendMessageAsync(ServiceBusMessage message, CancellationToken cancellationToken = default);     // ...   } ```"
  },
  {
    "id": "dotnet-subclient-factory-methods",
    "category": "Subclients {#dotnet-subclients}",
    "text": "DO provide factory methods to create a subclient."
  },
  {
    "id": "dotnet-subclient-factory-methods-suffix",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU MAY include a suffix the method that creates a subclient, according to the table below: | Client Type      | Naming Convention | Factory Method Naming Convention         | |------------------------|--------------------|--------------------------------------------------| | Service Client     | Client Suffix  | Get<client>Client()              | | Resource Client    | No Suffix     | Get<resource>()                | | Operation Group Client | No Suffix     | Get<group>Client()               | | Long Running Operation | Operation Suffix | (long LRO) Start prefix; (short LRO) no prefix | | Pageable          | Pageable<T> | Get<resource>s                 |"
  },
  {
    "id": "dotnet-subclient-factory-methods-parameters",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU SHOULD take a resource identifier as a parameter to the resource client factory method."
  },
  {
    "id": "dotnet-subclient-properties",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU SHOULD expose resource identifiers as properties on the resource client."
  },
  {
    "id": "dotnet-subclient-collections",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU MAY place operations on collections of resources a separate subclient to avoid cluttering the parent client with too many methods. While API usability is the primary reason for subclients, another motivating factor is resource efficiency. Clients need to be cached (https://devblogs.microsoft.com/azure-sdk/lifetime-management-and-thread-safety-guarantees-of-azure-sdk-net-clients/) so if the set of client instances is large or unlimited (in case the client takes a scoping parameter, like a hub, or a container), using subclients allows an application to cache the top level client and create instances of subclients on demand. In addition, if there is an expensive shared resource (e.g. an AMQP connection), subclients are preferred, as they naturally lead to resource sharing."
  },
  {
    "id": "dotnet-service-client-entry-point",
    "category": "Subclients {#dotnet-subclients}",
    "text": "YOU SHOULD use the HttpPipeline that belongs to the type providing the factory method to make network calls to the service from the subclient. An exception to this might be if subclient needs different pipeline policies than the parent client."
  },
  {
    "id": "dotnet-subclient-no-constructor",
    "category": "Subclients {#dotnet-subclients}",
    "text": "DO NOT provide a public constructor on a subclient. Subclients are non-instantiable by design."
  },
  {
    "id": "dotnet-subclient-mocking",
    "category": "Subclients {#dotnet-subclients}",
    "text": "DO provide a protected parameterless constructor on subclients for mocking. In many cases, an Azure SDK API should contain one service client and zero or more subclients. Both service clients and subclients have service methods. Consider adding more than one service client to the API in the following cases:"
  },
  {
    "id": "dotnet-service-client-multiple-target-customers",
    "category": "Choosing between Service Clients and Subclients {#dotnet-choosing-client-types}",
    "text": "YOU MAY consider providing an additional service client in an API when the service has different common scenarios for multiple target users, such as a service administrator and an end-user of the entities the administrator creates. For example, the Azure Form Recognizer library provides a FormRecognizerClient for application developers to read form fields in their applications, and a FormTrainingClient for data scientist customers to train the form recognition models."
  },
  {
    "id": "dotnet-service-client-advanced-scenarios",
    "category": "Choosing between Service Clients and Subclients {#dotnet-choosing-client-types}",
    "text": "YOU MAY consider providing an additional service client when a service has advanced scenarios you want to keep separate from the types that support the most common scenarios. In this case, consider using a .Specialized namespace to contain the additional clients. For example, the Azure Storage Blobs library provides a BlockBlobClient in the Azure.Storage.Blobs.Specialized namespace that gives finer grained control of how blobs are uploaded. For further discussion of designing APIs for advanced scenarios, please see the .NET Framework Guidelines (https://aka.ms/fxdg3) sections on progressive frameworks and the principle of layered architecture."
  },
  {
    "id": "dotnet-service-client-direct-resource-urls",
    "category": "Choosing between Service Clients and Subclients {#dotnet-choosing-client-types}",
    "text": "YOU MAY consider providing an additional service client for a service resource that is commonly referenced with a URL that points to it directly. This will allow users to instantiate a client directly from the resource endpoint, without needing to parse the URL to obtain the root service endpoint."
  },
  {
    "id": "dotnet-service-client-resource-hierarchy",
    "category": "Choosing between Service Clients and Subclients {#dotnet-choosing-client-types}",
    "text": "YOU MAY consider providing additional service clients for each level in a resource hierarchy. For service clients representing resources in a hierarchy, you should also provide a <parent>.Get<child>Client(...) method to retrieve the client for the named child. For example, the Azure Storage service provides an account that contains zero or more containers, which in turn contain zero or more blobs. The Azure SDK storage library provides service clients for each level: BlobServiceClient, BlobContainerClient, and BlobClient. ```C# public class BlobServiceClient {   // ...   public virtual BlobContainerClient GetBlobContainerClient(string blobContainerName);   // ... } public class BlobContainerClient {   // ...   public virtual BlobClient GetBlobClient(string blobName);   // ... } public class BlobClient {   // ... }  ``` Service methods are the methods on the client that invoke operations on the service. Here are the main service methods in the ConfigurationClient. They meet all the guidelines that are discussed below. ```csharp public class ConfigurationClient {   public virtual Task&lt;Response&lt;ConfigurationSetting&gt;&gt; AddAsync(ConfigurationSetting setting, CancellationToken cancellationToken = default);   public virtual Response&lt;ConfigurationSetting&gt; Add(ConfigurationSetting setting, CancellationToken cancellationToken = default);   public virtual Task&lt;Response&lt;ConfigurationSetting&gt;&gt; SetAsync(ConfigurationSetting setting, CancellationToken cancellationToken = default);   public virtual Response&lt;ConfigurationSetting&gt; Set(ConfigurationSetting setting, CancellationToken cancellationToken = default);   public virtual Task&lt;Response&lt;ConfigurationSetting&gt;&gt; GetAsync(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);   public virtual Response&lt;ConfigurationSetting&gt; Get(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);   public virtual Task&lt;Response&lt;ConfigurationSetting&gt;&gt; DeleteAsync(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);   public virtual Response&lt;ConfigurationSetting&gt; Delete(string key, SettingFilter filter = default, CancellationToken cancellationToken = default); } ```"
  },
  {
    "id": "dotnet-service-methods-sync-and-async",
    "category": "Sync and Async",
    "text": "DO provide both asynchronous and synchronous variants for all service methods. Many developers want to port existing applications to the Cloud. These applications are often synchronous, and the cost of rewriting them to be asynchronous is usually prohibitive. Calling asynchronous APIs from synchronous methods can only be done through a technique called sync-over-async, which can cause deadlocks (https://devblogs.microsoft.com/pfxteam/should-i-expose-synchronous-wrappers-for-asynchronous-methods/)  The Azure SDK provides synchronous APIs to minimize friction when porting existing application to Azure."
  },
  {
    "id": "dotnet-service-methods-naming",
    "category": "Sync and Async",
    "text": "DO ensure that the names of the asynchronous and the synchronous variants differ only by the Async suffix. Most methods in Azure SDK libraries should be named following the typical .NET method naming conventions. The Azure SDK Design Guidelines add special conventions for methods that access and manipulate server resources."
  },
  {
    "id": "general-client-standardize-verbs",
    "category": "Naming",
    "text": "YOU SHOULD use standard verbs for methods that access or manipulate server resources. <div class=\"standard-verbs-table-container\">   <!-- Table Header -->   <div class=\"standard-verbs-table-row\">     <div class=\"standard-verbs-table-cell standard-verbs-table-cell-header standard-verbs-table-cell-verb\">Verb</div>     <div class=\"standard-verbs-table-cell standard-verbs-table-cell-header\">Parameters</div>     <div class=\"standard-verbs-table-cell standard-verbs-table-cell-header\">Returns</div>     <div class=\"standard-verbs-table-cell standard-verbs-table-cell-header standard-verbs-table-cell-comments\">       Comments</div>   </div>   <!-- Table Rows -->   {% for item in data %}   {% assign mod = forloop.index0 | modulo:2 %}   {% if mod == 0 %}   {% include tables/standard_verbs_row.html perRowCellStyle=\"standard-verbs-table-cell-pair\"%}   {% else %}   {% include tables/standard_verbs_row.html perRowStyle=\"\"%}   {% endif %}   {% endfor %} </div> "
  },
  {
    "id": "dotnet-service-methods-cancellation",
    "category": "Cancellation",
    "text": "DO ensure all service methods, both asynchronous and synchronous, take an optional CancellationToken parameter called cancellationToken or, in case of protocol methods, an optional RequestContext parameter called context. The token should be further passed to all calls that take a cancellation token. DO NOT check the token manually, except when running a significant amount of CPU-bound work within the library, e.g. a loop that can take more than a typical network call."
  },
  {
    "id": "dotnet-service-methods-virtual",
    "category": "Mocking",
    "text": "DO make service methods virtual. Virtual methods are used to support mocking. See Support for Mocking for details."
  },
  {
    "id": "dotnet-service-methods-response-sync",
    "category": "Return Types",
    "text": "DO return Response<T> or Response from synchronous methods. T represents the content of the response, as described below."
  },
  {
    "id": "dotnet-service-methods-response-async",
    "category": "Return Types",
    "text": "DO return Task<Response<T>> or Task<Response> from asynchronous methods that make network requests. There are two possible return types from asynchronous methods: Task and ValueTask. Your code will be doing a network request in the majority of cases. The Task variant is more appropriate for this use case. For more information, see this blog post (https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/#user-content-should-every-new-asynchronous-api-return-valuetask--valuetasktresult)  T represents the content of the response, as described below. The T can be either an unstructured payload (e.g. bytes of a storage blob) or a model type representing deserialized response content."
  },
  {
    "id": "dotnet-service-return-unstructured-type",
    "category": "Return Types",
    "text": "DO use one of the following return types to represent an unstructured payload: System.IO.Stream - for large payloads byte[] - for small payloads ReadOnlyMemory<byte> - for slices of small payloads"
  },
  {
    "id": "dotnet-service-return-model-type",
    "category": "Return Types",
    "text": "DO return a model type if the content has a schema and can be deserialized. For more information, see Model Types"
  },
  {
    "id": "dotnet-service-methods-thread-safety",
    "category": "Thread Safety",
    "text": "DO be thread-safe. All public members of the client type must be safe to call from multiple threads concurrently. Service methods fall into two main groups when it comes to the number and complexity of parameters they accept: Service Methods with Simple Inputs, simple methods for short Service Methods with Complex Inputs, complex methods for short Simple methods are methods that take up to six parameters, with most of the parameters being simple BCL primitives. Complex methods are methods that take large number of parameters and typically correspond to REST APIs with complex request payloads. Simple methods should follow standard .NET Framework Design Guidelines (https://aka.ms/fxdg3) for parameter list and overload design. Complex methods should use option parameter to represent the request payload, and consider providing convenience simple overloads for most common scenarios. ```csharp public class BlobContainerClient {   // simple service method   public virtual Response&lt;BlobInfo&gt; UploadBlob(string blobName, Stream content, CancellationToken cancellationToken = default);   // complex service method   public virtual Response&lt;BlobInfo&gt; CreateBlob(BlobCreateOptions options = null, CancellationToken cancellationToken = default);   // convinience overload[s]   public virtual Response&lt;BlobContainerInfo&gt; CreateBlob(string blobName, CancellationToken cancellationToken = default); } public class BlobCreateOptions {   public PublicAccessType Access { get; set; }   public IDictionary&lt;string, string&gt; Metadata { get; }   public BlobContainerEncryptionScopeOptions Encryption { get; set; }   ... } ``` The Options class is designed similarly to .NET custom attributes, where required service method parameters are modeled as Options class constructor parameters and get-only properties, and optional parameters are get-set properties."
  },
  {
    "id": "dotnet-params-complex",
    "category": "Service Method Parameters {#dotnet-parameters}",
    "text": "DO use the options parameter pattern for complex service methods."
  },
  {
    "id": "dotnet-params-complex",
    "category": "Service Method Parameters {#dotnet-parameters}",
    "text": "YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future."
  },
  {
    "id": "dotnet-params-complex",
    "category": "Service Method Parameters {#dotnet-parameters}",
    "text": "YOU MAY add simple overloads of methods using the options parameter pattern. If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset. ```csharp   // main overload taking the options property bag   public virtual Response&lt;BlobInfo&gt; CreateBlob(BlobCreateOptions options = null, CancellationToken cancellationToken = default);   // simple overload with a subset of parameters of the options bag   public virtual Response&lt;BlobContainerInfo&gt; CreateBlob(string blobName, CancellationToken cancellationToken = default); } ```"
  },
  {
    "id": "dotnet-params-options",
    "category": "Service Method Parameters {#dotnet-parameters}",
    "text": "YOU MAY name the option parameter type with the 'Options' suffix. Service methods take two kinds of parameters: service parameters and client parameters. Service parameters are sent across the wire to the service as URL segments, query parameters, request header values, and request bodies (typically JSON or XML). Client parameters are used solely within the client library and are not sent to the service; examples are path parameters, CancellationTokens or file paths."
  },
  {
    "id": "dotnet-params-client-validation",
    "category": "Parameter Validation",
    "text": "DO validate client parameters."
  },
  {
    "id": "dotnet-params-service-validation",
    "category": "Parameter Validation",
    "text": "DO NOT validate service parameters. Common parameter validations include null checks, empty string checks, and range checks. Let the service validate its parameters."
  },
  {
    "id": "dotnet-params-test-devex",
    "category": "Parameter Validation",
    "text": "DO test the developer experience when invalid service parameters are passed in. Ensure clear error messages are generated by the client. If the developer experience is inadequate, work with the service team to correct the problem. Many Azure REST APIs return collections of data in batches or pages. A client library will expose such APIs as special enumerable types Pageable<T> or AsyncPageable<T>. These types are located in the Azure.Core package. For example, the configuration service returns collections of items as follows: ```csharp public class ConfigurationClient {   // asynchronous API returning a collection of items   public virtual AsyncPageable&lt;Response&lt;ConfigurationSetting&gt;&gt; GetConfigurationSettingsAsync(...);   // synchronous variant of the method above   public virtual Pageable&lt;ConfigurationSetting&gt; GetConfigurationSettings(...);   ... } ```"
  },
  {
    "id": "dotnet-pagination-ienumerable",
    "category": "Methods Returning Collections (Paging) {#dotnet-paging}",
    "text": "DO return Pageable<T> or AsyncPageable<T> from service methods that return a collection of items. Some service operations, known as Long Running Operations or LROs take a long time (up to hours or days). Such operations do not return their result immediately, but rather are started, their progress is polled, and finally the result of the operation is retrieved. Azure.Core library exposes an abstract type called Operation<T>, which represents such LROs and supports operations for polling and waiting for status changes, and retrieving the final operation result. A service method invoking a long running operation will return a subclass of Operation<T>, as shown below. Note that some older libraries use a slightly different, older LRO pattern. In the old pattern, LRO methods started with the prefix 'Start' and did not take the WaitUntil parameter. Such libraries are free to continue using this older pattern, or they can transition to the new pattern. ```csharp // the following type is located in Azure.Core public abstract class Operation&lt;T&gt; : Operation {   public abstract bool HasCompleted { get; }   public abstract bool HasValue { get; }   public abstract string Id { get; }   public abstract T Value { get; } // throws if CachedStatus != Succeeded   public abstract Response GetRawResponse();   public abstract Response UpdateStatus(CancellationToken cancellationToken = default);   public abstract ValueTask&lt;Response&gt; UpdateStatusAsync(CancellationToken cancellationToken = default);   public virtual Response&lt;T&gt; WaitForCompletion(CancellationToken cancellationToken = default);   public virtual Response&lt;T&gt; WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);\t   public virtual ValueTask&lt;Response&lt;T&gt;&gt; WaitForCompletionAsync(CancellationToken cancellationToken = default);\t   public virtual ValueTask&lt;Response&lt;T&gt;&gt; WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default);   // inherited members returning untyped responses   public virtual Response WaitForCompletionResponse(CancellationToken cancellationToken = default);\t   public virtual Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken = default);\t   public virtual ValueTask&lt;Response&gt; WaitForCompletionResponseAsync(CancellationToken cancellationToken = default);\t   public virtual ValueTask&lt;Response&gt; WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default); } ``` Client libraries need to inherit from Operation<T> not only to implement all abstract members, but also to provide a constructor required to access an existing LRO (an LRO initiated by a different process). ```csharp public class CopyFromUriOperation : Operation&lt;long&gt; {   public CopyFromUriOperation(string id, BlobBaseClient client);   ... } public class BlobBaseClient {   public virtual CopyFromUriOperation CopyFromUri(WaitUntil wait, ..., CancellationToken cancellationToken = default);   public virtual Task&lt;CopyFromUriOperation&gt; CopyFromUriAsync(WaitUntil wait, ..., CancellationToken cancellationToken = default); } ``` The following code snippet shows how an SDK consumer would use the Operation to poll for a response. ```csharp BlobBaseClient client = ... // automatic polling {   Operation&lt;long&gt; operation = await client.CopyFromUri(WaitUntil.Completed, ...);   Console.WriteLine(operation.Value); } // manual polling {   CopyFromUriOperation operation = await client.CopyFromUriAsync(WaitUntil.Started, ...);   while (true)   {     await operation.UpdateStatusAsync();     if (operation.HasCompleted) break;     await Task.Delay(1000); // play some elevator music   }   if (operation.HasValue) Console.WriteLine(operation.Value); } // saving operation ID {   CopyFromUriOperation operation = await client.CopyFromUriAsync(WaitUntil.Started, ...);   string operationId = operation.Id;   // two days later   var operation2 = new CopyFromUriOperation(operationId, client);   long value = await operation2.WaitForCompletionAsync(); } ```"
  },
  {
    "id": "dotnet-lro-return",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "DO return a subclass of Operation<T> from LRO methods."
  },
  {
    "id": "dotnet-lro-waituntil",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "DO take WaitUntil as the first parameter to LRO methods."
  },
  {
    "id": "dotnet-lro-subclass",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "YOU MAY add additional APIs to subclasses of Operation<T>. For example, some subclasses add a constructor allowing to create an operation instance from a previously saved operation ID. Also, some subclasses are more granular states besides the IsCompleted and HasValue states that are present on the base class."
  },
  {
    "id": "dotnet-lro-constructor",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "DO provide a public constructor on subclasses of Operation<T> to allow users to access an existing LRO."
  },
  {
    "id": "dotnet-lro-constructor-for-mocking",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "DO provide protected parameterless constructor for mocking in subclasses of Operation<T>. ```csharp public class CopyFromUriOperation {   protected CopyFromUriOperation(); } ```"
  },
  {
    "id": "dotnet-lro-mocking-properties",
    "category": "Methods Invoking Long Running Operations {#dotnet-longrunning}",
    "text": "DO make all properties virtual to allow mocking. ```csharp public class CopyFromUriOperation {   public virtual Uri SourceUri { get; } } ``` Some services support conditional requests that are used to implement optimistic concurrency control. In Azure, optimistic concurency is typically implemented using If-Match headers and ETags. See Managing Concurrency in Blob Storage (https://docs.microsoft.com/en-us/azure/storage/blobs/concurrency-manage?tabs=dotnet) as a good example."
  },
  {
    "id": "dotnet-conditional-etag",
    "category": "Conditional Request Methods",
    "text": "DO use Azure.Core ETag to represent ETags."
  },
  {
    "id": "dotnet-conditional-matchcondition",
    "category": "Conditional Request Methods",
    "text": "YOU MAY take MatchConditions (https://docs.microsoft.com/en-us/dotnet/api/azure.matchconditions?view=azure-dotnet) RequestConditions (https://docs.microsoft.com/en-us/dotnet/api/azure.requestconditions?view=azure-dotnet) (or a custom subclass) as a parameter to conditional service call methods. : more guidelines comming. see https://github.com/Azure/azure-sdk/issues/2154 In addition to service client types, Azure SDK APIs provide and use other supporting types as well. This section describes guidelines for the design model types and all their transitive closure of public dependencies (i.e. the model graph). A model type is a representation of a REST service's resource. For example, review the configuration service model type below: ```csharp public sealed class ConfigurationSetting : IEquatable&lt;ConfigurationSetting&gt; {   public ConfigurationSetting(string key, string value, string label = default);   public string ContentType { get; set; }   public string ETag { get; internal set; }   public string Key { get; set; }   public string Label { get; set; }   public DateTimeOffset LastModified { get; internal set; }   public bool Locked { get; internal set; }   public IDictionary&lt;string, string&gt; Tags { get; }   public string Value { get; set; }   public bool Equals(ConfigurationSetting other);   [EditorBrowsable(EditorBrowsableState.Never)]   public override bool Equals(object obj);   [EditorBrowsable(EditorBrowsableState.Never)]   public override int GetHashCode();   [EditorBrowsable(EditorBrowsableState.Never)]   public override string ToString(); } ``` This model is returned from service methods as follows: ```csharp public class ConfigurationClient {   public virtual Task&lt;Response&lt;ConfigurationSetting&gt;&gt; GetAsync(...);   public virtual Response&lt;ConfigurationSetting&gt; Get(...);   ... } ```"
  },
  {
    "id": "dotnet-service-return-model-public-getters",
    "category": "Model Types {#dotnet-model-types}",
    "text": "DO ensure model public properties are get-only if they aren't intended to be changed by the user. Most output-only models can be fully read-only. Models that are used as both outputs and inputs (i.e. received from and sent to the service) typically have a mixture of read-only and read-write properties. For example, the Locked property of ConfigurationSetting is controlled by the service. It shouldn't be changed by the user. The ContentType property, by contrast, can be modified by the user. ```csharp public sealed class ConfigurationSetting : IEquatable&lt;ConfigurationSetting&gt; {   public string ContentType { get; set; }   public bool Locked { get; internal set; } } ``` Ensure you include an internal setter to allow for deserialization. For more information, see JSON Serialization."
  },
  {
    "id": "dotnet-service-models-prefer-structs",
    "category": "Model Types {#dotnet-model-types}",
    "text": "DO ensure model types are structs, if they meet the criteria for being structs. Good candidates for struct are types that are small and immutable, especially if they are often stored in arrays. See .NET Framework Design Guidelines (https://aka.ms/fxdg3) for details."
  },
  {
    "id": "dotnet-service-models-basic-data-interfaces",
    "category": "Model Types {#dotnet-model-types}",
    "text": "YOU SHOULD implement basic data type interfaces on model types, per .NET Framework Design Guidelines (https://aka.ms/fxdg3)  For example, implement IEquatable<T>, IComparable<T>, IEnumerable<T>, etc. if applicable."
  },
  {
    "id": "dotnet-service-return-model-collections",
    "category": "Model Types {#dotnet-model-types}",
    "text": "YOU SHOULD use the following collection types for properties of model types: IReadOnlyList<T> and IList<T> for most collections IReadOnlyDictionary<T> and IDictionary<T> for lookup tables T[], Memory<T>, and ReadOnlyMemory<T> when low allocations and performance are critical Note that this guidance does not apply to input parameters. Input parameters representing collections should follow standard .NET Framework Design Guidelines (https://aka.ms/fxdg3) e.g. use IEnumerable<T> is allowed. Also, this guidance does not apply to return types of service method calls. These should be using Pageable<T> and AsyncPageable<T> discussed in Methods Returning Collections."
  },
  {
    "id": "dotnet-service-models-namespace",
    "category": "Model Types {#dotnet-model-types}",
    "text": "YOU MAY place output model types in .Models subnamespace to avoid cluttering the main namespace with too many types. It is important for the main namespace of a client library to be clutter free. Some client libraries have a relatively small number of model types, and these should keep the model types in the main namespace. For example, model types of Azure.Data.AppConfiguration package are in the main namespace. On the other hand, model types of Azure.Storage.Blobs package are in .Models subnamespace. ```csharp namespace Azure.Storage.Blobs {   public class BlobClient { ... }   public class BlobClientOptions { ... }   ... } namespace Azure.Storage.Blobs.Models {   ...   public class BlobContainerItem { ... }   public class BlobContainerProperties { ...}   ... } ```"
  },
  {
    "id": "dotnet-service-editor-browsable-state",
    "category": "Model Types {#dotnet-model-types}",
    "text": "YOU SHOULD apply the [EditorBrowsable(EditorBrowsableState.Never)] attribute to methods on the model type that the user isn't meant to call. Adding this attribute will hide the methods from being shown with IntelliSense. A user will almost never call GetHashCode() directly. Equals(object) is almost never called if the type implements IEquatable<T> (which is preferred). Hide the ToString() method if it isn't overridden. ```csharp public sealed class ConfigurationSetting : IEquatable&lt;ConfigurationSetting&gt; {   [EditorBrowsable(EditorBrowsableState.Never)]   public override bool Equals(object obj);   [EditorBrowsable(EditorBrowsableState.Never)]   public override int GetHashCode(); } ``` {% include note.html content=\"Unlike service clients, model types aren't required to be thread-safe, as they're rarely shared between threads.\" %}"
  },
  {
    "id": "dotnet-models-in-mocks",
    "category": "Model Types {#dotnet-model-types}",
    "text": "DO ensure all model types can be used in mocks. In practice, you need to provide public APIs to construct model graphs. See Support for Mocking for details. : issue #2298"
  },
  {
    "id": "dotnet-enums",
    "category": "Enumerations",
    "text": "DO use an enum for parameters, properties, and return types when values are known."
  },
  {
    "id": "dotnet-enums-exception",
    "category": "Enumerations",
    "text": "YOU MAY use a readonly struct in place of an enum that declares well-known fields but can contain unknown values returned from the service, or user-defined values passed to the service. See enumeration-like structure documentation for implementation details. The Azure.Core package provides common functionality for client libraries. Documentation and usage examples can be found in the azure/azure-sdk-for-net (https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/core/Azure.Core) repository."
  },
  {
    "id": "dotnet-primitives-etag",
    "category": "Using Primitive Types",
    "text": "DO use Azure.ETag to represent ETags. The Azure.ETag type is located in Azure.Core package."
  },
  {
    "id": "dotnet-primitives-uri",
    "category": "Using Primitive Types",
    "text": "DO use System.Uri to represent URIs. In .NET, throwing exceptions is how we communicate to library consumers that the services returned an error."
  },
  {
    "id": "dotnet-errors-response-failed",
    "category": "Exceptions {#dotnet-errors}",
    "text": "DO throw RequestFailedException or its subtype when a service method fails with non-success status code. The exception is available in Azure.Core package: ```csharp public class RequestFailedException : Exception {   public RequestFailedException(Response response);   public RequestFailedException(Response response, Exception innerException);   public RequestFailedException(Response response, Exception innerException, RequestFailedDetailsParser detailsParser);   public int Status { get; } } ``` The exception message will be formed from the passed in Response content. For example: ```csharp if (response.Status != 200) {   throw new RequestFailedException(response); } ```"
  },
  {
    "id": "dotnet-errors-use-response-failed-when-possible",
    "category": "Exceptions {#dotnet-errors}",
    "text": "DO use RequestFailedException or one of its subtypes where possible."
  },
  {
    "id": "dotnet-request-failed-details-parser",
    "category": "Exceptions {#dotnet-errors}",
    "text": "DO provide RequestFailedDetailsParser for non-standard error formats. If customization is required to parse the response content, e.g. because the service does not adhere to the standard error format as represented by the ResponseError type, libraries can must implement a RequestFailedDetailsParser and pass the parser into the construction of the HttpPipeline via the HttpPipelineOptions type. If more granular control is required than associating the parser per pipeline, there is a constructor of RequestFailedException that takes a RequestFailedDetailsParser that may be used. Don't introduce new exception types unless there's a programmatic scenario for handling the new exception that's different than RequestFailedException The client library consumer should construct a service client using just the constructor. After construction, service methods can successfully invoke service operations. The constructor parameters must take all parameters required to create a functioning client, including all information needed to authenticate with the service. The general constructor pattern refers to binding parameters. ```csharp // simple constructors public &lt;service_name&gt;Client(&lt;simple_binding_parameters&gt;); public &lt;service_name&gt;Client(&lt;simple_binding_parameters&gt;, &lt;service_name&gt;ClientOptions options); // 0 or more advanced constructors public &lt;service_name&gt;Client(&lt;advanced_binding_parameters&gt;, &lt;service_name&gt;ClientOptions options = default); ``` Typically, binding parameters would include a URI to the service endpoint and authorization credentials. For example, the blob service client can be bound using any of: a connection string (which contains both endpoint information and credentials), an endpoint (for anonymous access), an endpoint and credentials (for authenticated access). ```csharp // hello world constructors using the main authentication method on the service's Azure Portal (typically a connection string) // we don't want to use default parameters here; all other overloads can use default parameters public BlobServiceClient(string connectionString) public BlobServiceClient(string connectionString, BlobClientOptions options) // anonymous access public BlobServiceClient(Uri uri, BlobClientOptions options = default) // using credential types public BlobServiceClient(Uri uri, StorageSharedKeyCredential credential, BlobClientOptions options = default) public BlobServiceClient(Uri uri, TokenCredential credential, BlobClientOptions options = default) ```"
  },
  {
    "id": "dotnet-auth-azure-core",
    "category": "Authentication {#dotnet-authentication}",
    "text": "YOU SHOULD use credential types provided in the Azure.Core package. Currently, Azure.Core provides TokenCredential for OAuth style tokens, including MSI credentials."
  },
  {
    "id": "dotnet-auth-rolling-credentials",
    "category": "Authentication {#dotnet-authentication}",
    "text": "DO support changing credentials without having to create a new client instance. Credentials passed to the constructors must be read before every request (for example, by calling TokenCredential.GetToken())."
  },
  {
    "id": "dotnet-auth-arch-review",
    "category": "Authentication {#dotnet-authentication}",
    "text": "DO contact [adparch] if you want to add a new credential type."
  },
  {
    "id": "dotnet-auth-connection-strings",
    "category": "Authentication {#dotnet-authentication}",
    "text": "YOU MAY offer a way to create credentials from a connection string only if the service offers a connection string via the Azure portal. Don't ask users to compose connection strings manually if they aren't available through the Azure portal. Connection strings are immutable. It's impossible for an application to roll over credentials when using connection strings."
  },
  {
    "id": "dotnet-namespaces-naming",
    "category": "Namespaces {#dotnet-namespace-naming}",
    "text": "DO adhere to the following scheme when choosing a namespace: Azure.<group>.<service>[.<feature>] For example, Azure.Storage.Blobs."
  },
  {
    "id": "dotnet-namespaces-approved-list",
    "category": "Namespaces {#dotnet-namespace-naming}",
    "text": "DO use one of the following pre-approved namespace groups: Azure.AI for artificial intelligence, including machine learning Azure.Analytics for client libraries that gather or process analytics data Azure.Communication communication services Azure.Core for libraries that aren't service specific Azure.Cosmos for object database technologies Azure.Data for client libraries that handle databases or structured data stores Azure.DigitalTwins for DigitalTwins related technologies Azure.Identity for authentication and authorization client libraries Azure.IoT for client libraries dealing with the Internet of Things. Use Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions. Do not use IoT more than once in a namespace.  Use Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions. Do not use IoT more than once in a namespace. Azure.Media for client libraries that deal with audio, video, or mixed reality Azure.Messaging for client libraries that provide messaging services, such as push notifications or pub-sub. Azure.Monitor for observability and Azure Monitor client libraries. Azure.ResourceManager.[ResourceProvider] for management plane client libraries for a given resource provider. For example the compute management plane namespace would be Azure.ResourceManager.Compute.  For example the compute management plane namespace would be Azure.ResourceManager.Compute. Azure.Search for search technologies Azure.Security for client libraries dealing with security Azure.Storage for client libraries that handle unstructured data Use Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions. Do not use IoT more than once in a namespace. For example the compute management plane namespace would be Azure.ResourceManager.Compute. If you think a new group should be added to the list, contact [adparch]."
  },
  {
    "id": "dotnet-namespaces-registration",
    "category": "Namespaces {#dotnet-namespace-naming}",
    "text": "DO register all namespaces with [adparch]."
  },
  {
    "id": "dotnet-namespaces-location",
    "category": "Namespaces {#dotnet-namespace-naming}",
    "text": "DO NOT place APIs in the second-level namespace (directly under the Azure namespace)."
  },
  {
    "id": "dotnet-namespaces-models",
    "category": "Namespaces {#dotnet-namespace-naming}",
    "text": "YOU SHOULD consider placing model types in a .Models namespace if number of model types is or might become large. See model type guidelines for details. All client libraries must support mocking to enable non-live testing of service clients by customers. Here is an example of how the ConfigurationClient can be mocked using [Moq] (a popular .NET mocking library): ```csharp // Create a mock response var mockResponse = new Mock&lt;Response&gt;(); // Create a client mock var mock = new Mock&lt;ConfigurationClient&gt;(); // Setup client method mock.Setup(c =&gt; c.Get(\"Key\", It.IsAny&lt;string&gt;(), It.IsAny&lt;DateTimeOffset&gt;(), It.IsAny&lt;CancellationToken&gt;()))   .Returns(new Response&lt;ConfigurationSetting&gt;(mockResponse.Object, ConfigurationModelFactory.ConfigurationSetting(\"Key\", \"Value\"))); // Use the client mock ConfigurationClient client = mock.Object; ConfigurationSetting setting = client.Get(\"Key\"); Assert.AreEqual(\"Value\", setting.Value); ``` Review the full sample (https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/appconfiguration/Azure.Data.AppConfiguration/samples/Sample7_MockClient.md) in the GitHub repository."
  },
  {
    "id": "dotnet-mocking-constructor",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO provide protected parameterless constructor for mocking."
  },
  {
    "id": "dotnet-mocking-virtual-method",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO make all service methods virtual."
  },
  {
    "id": "dotnet-mocking-virtual-properties",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO make all properties virtual. ```csharp   public class BlobContainerClient {     public virtual string Name { get; }     public virtual Uri Uri { get; }   } ```"
  },
  {
    "id": "dotnet-mocking-virtual-getclient-method",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO make methods returning other clients virtual. ```csharp public class BlobContainerClient {   public virtual BlobClient GetBlobClient(); } ```"
  },
  {
    "id": "dotnet-mocking-extensions",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO use instance methods instead of extension methods when defined in the same assembly. The instance methods are simpler to mock. ```csharp public class BlobContainerClient {   // This method is possible to mock   public virtual AppendBlobClient GetAppendBlobClient() {} } public class BlobContainerClientExtensions {   // This method is impossible to mock   public static AppendBlobClient GetAppendBlobClient(this BlobContainerClient containerClient) {} } ```"
  },
  {
    "id": "dotnet-mocking-factory-builder",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO provide factory or builder for constructing model graphs returned from virtual service methods. Model types shouldn't have public constructors. Instances of the model are typically returned from the client library, and are not constructed by the consumer of the library. Mock implementations need to create instances of model types. Implement a static class called <service>ModelFactory in the same namespace as the model types: ```csharp public static class ConfigurationModelFactory {   public static ConfigurationSetting ConfigurationSetting(string key, string value, string label=default, string contentType=default, ETag eTag=default, DateTimeOffset? lastModified=default, bool? locked=default);   public static SettingBatch SettingBatch(ConfigurationSetting[] settings, string link, SettingSelector selector); } ```"
  },
  {
    "id": "dotnet-mocking-factory-builder-methods",
    "category": "Support for Mocking {#dotnet-mocking}",
    "text": "DO hide older overloads and avoid ambiguity. When read-only properties are added to models and factory methods must be added to optionally set these properties, you must hide the previous method and remove all default parameter values to avoid ambiguity: ```csharp public static class ConfigurationModelFactory {   [EditorBrowsable(EditorBrowsableState.Never)]   public static ConfigurationSetting ConfigurationSetting(string key, string value, string label, string contentType, ETag eTag, DateTimeOffset? lastModified, bool? locked) =&gt;     ConfigurationSetting(key, value, label, contentType, eTag, lastModified, locked, default);   public static ConfigurationSetting ConfigurationSetting(string key, string value, string label=default, string contentType=default, ETag eTag=default, DateTimeOffset? lastModified=default, bool? locked=default, int? ttl=default); } ```"
  },
  {
    "id": "dotnet-packaging-nuget",
    "category": "Packaging {#dotnet-packaging}",
    "text": "DO package all components as NuGet packages. If your client library is built by the Azure SDK engineering systems, all packaging requirements will be met automatically. Follow the .NET packaging guidelines (https://docs.microsoft.com/dotnet/standard/library-guidance/nuget) if you're self-publishing. For Microsoft owned packages we need to support both windows (for windows dump diagnostics) and portable (for x-platform debugging) pdb formats which means you need to publish them to the Microsoft symbol server and not the Nuget symbol server which only supports portable pdbs."
  },
  {
    "id": "dotnet-packaging-naming",
    "category": "Packaging {#dotnet-packaging}",
    "text": "DO name the package based on the name of the main namespace of the component. For example, if the component is in the Azure.Storage.Blobs namespace, the component DLL will be Azure.Storage.Blobs.dll and the NuGet package will b`Azure.Storage.Blobs```."
  },
  {
    "id": "dotnet-packaging-granularity",
    "category": "Packaging {#dotnet-packaging}",
    "text": "YOU SHOULD place small related components that evolve together in a single NuGet package."
  },
  {
    "id": "dotnet-build-net-standard",
    "category": "Packaging {#dotnet-packaging}",
    "text": "DO build all libraries for [.NET Standard 2.0]. Use the following target setting in the .csproj file: ```xml &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt; ```"
  },
  {
    "id": "dotnet-build-multi-targeting-api",
    "category": "Packaging {#dotnet-packaging}",
    "text": "DO define the same APIs for all [target framework monikers (TFMs)][.NET Target Framework Monikers]. You may multi-target client libraries to different [TFMs][.NET Target Framework Monikers] but the public API must be the same for all targets including class, interface, parameter, and return types. There are occasions when common code needs to be shared between several client libraries. For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "dotnet-commonlib-approval",
    "category": "Common Libraries",
    "text": "DO gain [Architecture Board] discuss how to design such common library."
  },
  {
    "id": "dotnet-versioning-backwards-compatibility",
    "category": "Client Versions",
    "text": "DO be 100% backwards compatible with older versions of the same package. For detailed rules, see .NET Breaking Changes (https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/breaking-change-rules.md) "
  },
  {
    "id": "dotnet-versioning-new-package",
    "category": "Client Versions",
    "text": "DO introduce a new package (with new assembly names, new namespace names, and new type names) if you must do an API breaking change. Breaking changes should happen rarely, if ever. Register your intent to do a breaking change with [adparch]. You'll need to have a discussion with the language architect before approval. Consistent version number scheme allows consumers to determine what to expect from a new version of the library."
  },
  {
    "id": "dotnet-version-semver",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO use MAJOR.MINOR.PATCH format for the version of the library dll and the NuGet package. Use _-beta.N suffix for beta package versions. For example, 1.0.0-beta.2."
  },
  {
    "id": "dotnet-version-change-on-release",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO change the version number of the client library when ANYTHING changes in the client library."
  },
  {
    "id": "dotnet-version-patching",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO increment the patch version when fixing a bug."
  },
  {
    "id": "dotnet-version-features-in-patch",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO NOT include new APIs in a patch release."
  },
  {
    "id": "dotnet-version-add-feature",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO increment the major or minor version when adding support for a service API version."
  },
  {
    "id": "dotnet-version-add-api",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO increment the major or minor version when adding a new method to the public API."
  },
  {
    "id": "dotnet-version-major-changes",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "YOU SHOULD increment the major version when making large feature changes."
  },
  {
    "id": "dotnet-version-change-on-release",
    "category": "Package Version Numbers {#dotnet-versionnumbers}",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": "dotnet-dependencies-minimize",
    "category": "Dependencies {#dotnet-dependencies}",
    "text": "YOU SHOULD minimize dependencies outside of the .NET Standard and Azure.Core packages."
  },
  {
    "id": "dotnet-dependencies-list",
    "category": "Dependencies {#dotnet-dependencies}",
    "text": "DO NOT depend on any NuGet package except the following packages: Azure.* packages from the [azure/azure-sdk-for-net] repository. System.Text.Json. Microsoft.BCL.AsyncInterfaces. packages produced by your own team. In the past, JSON.NET (https://www.newtonsoft.com/json) aka Newtonsoft.Json, was commonly used for serialization and deserialization. Use the System.Text.Json (https://www.nuget.org/packages/System.Text.Json/) package that is now a part of the .NET platform instead."
  },
  {
    "id": "dotnet-dependencies-exposing",
    "category": "Dependencies {#dotnet-dependencies}",
    "text": "DO NOT publicly expose types from dependencies unless the types follow these guidelines as well. Native dependencies introduce lots of complexities to .NET libraries and so they should be avoided."
  },
  {
    "id": "dotnet-problems-too-many-types",
    "category": "Native Code",
    "text": "YOU SHOULD NOT native dependencies."
  },
  {
    "id": "dotnet-docs-document-everything",
    "category": "Documentation Comments {#dotnet-documentation}",
    "text": "DO document every exposed (public or protected) type and member within your library's code."
  },
  {
    "id": "dotnet-docs-docstrings",
    "category": "Documentation Comments {#dotnet-documentation}",
    "text": "DO use C# documentation comments (https://docs.microsoft.com/dotnet/csharp/language-reference/language-specification/documentation-comments) for reference documentation. See the [documentation guidelines]({{ site.baseurl }}/general_documentation.html) for language-independent guidelines for how to provide good documentation."
  },
  {
    "id": "dotnet-general-repository",
    "category": "Repository Guidelines {#dotnet-repository}",
    "text": "DO locate all source code and README in the [azure/azure-sdk-for-net] GitHub repository."
  },
  {
    "id": "dotnet-general-engsys",
    "category": "Repository Guidelines {#dotnet-repository}",
    "text": "DO follow Azure SDK engineering systems guidelines for working in the [azure/azure-sdk-for-net] GitHub repository. : issue #2338"
  },
  {
    "id": "dotnet-docs-readme",
    "category": "README {#dotnet-repository-readme}",
    "text": "DO have a README.md file in the component root folder. An example of a good README.md file can be found here (https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/appconfiguration/Azure.Data.AppConfiguration/README.md) "
  },
  {
    "id": "dotnet-docs-readme-consumer",
    "category": "README {#dotnet-repository-readme}",
    "text": "DO optimize the README.md for the consumer of the client library. The contributor guide (CONTRIBUTING.md) should be a separate file linked to from the main component README.md. Each client library should have a quickstart guide with code samples. Developers like to learn about a library by looking at sample code; not by reading in-depth technology papers."
  },
  {
    "id": "dotnet-samples-location",
    "category": "Samples {#dotnet-samples}",
    "text": "DO have usage samples in samples subdirectory of main library directory. For a complete example, see the Configuration Service samples (https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration/samples) "
  },
  {
    "id": "dotnet-samples-readme",
    "category": "Samples {#dotnet-samples}",
    "text": "DO have a README.md file with the following front matter: ```yml --- page_type: sample languages: - csharp products: - azure - azure-app-configuration name: Azure.Data.AppConfiguration samples for .NET description: Samples for the Azure.Data.AppConfiguration client library --- ``` The README.md file should be written as a getting started guide. See the ServiceBus README (https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/README.md) for a good example."
  },
  {
    "id": "dotnet-samples-readme-links",
    "category": "Samples {#dotnet-samples}",
    "text": "DO link to each of the samples files using a brief description as the link text."
  },
  {
    "id": "dotnet-samples-naming",
    "category": "Samples {#dotnet-samples}",
    "text": "DO have a sample file called Sample1_HelloWorld.md. All other samples are ordered from simplest to most complex using the Sample<number>_ prefix."
  },
  {
    "id": "dotnet-sync-samples-naming",
    "category": "Samples {#dotnet-samples}",
    "text": "DO use synchronous APIs in the Sample1_HelloWorld.md sample. Add a second sample named Sample1_HelloWorldAsync.md that does the same thing as Sample1_HelloWorld.md using asynchronous code."
  },
  {
    "id": "dotnet-samples-source-snippets",
    "category": "Samples {#dotnet-samples}",
    "text": "DO use #regions in source with a unique identifier starting with \"Snippet:\" like Snippet:AzConfigSample1_CreateConfigurationClient. This must be unique within the entire repo."
  },
  {
    "id": "dotnet-samples-snippets",
    "category": "Samples {#dotnet-samples}",
    "text": "DO C# code fences with the corresponding #region name like so: ```markdown ```C# Snippet:AzConfigSample1_CreateConfigurationClient var client = new ConfigurationClient(connectionString); ``` ```"
  },
  {
    "id": "dotnet-samples-build",
    "category": "Samples {#dotnet-samples}",
    "text": "DO make sure all the samples build and run as part of the CI process. : Update guidance on samples to reflect what we do in most places. Some .NET Framework Design Guidelines (https://aka.ms/fxdg3) have been notoriously overlooked in earlier Azure SDKs. This section serves as a way to highlight these guidelines."
  },
  {
    "id": "dotnet-problems-too-many-types",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "YOU SHOULD NOT have many types in the main namespace. Number of types is directly proportional to the perceived complexity of a library."
  },
  {
    "id": "dotnet-problems-abstractions",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "DO NOT use abstractions unless the Azure SDK both returns and consumes the abstraction. An abstraction is either an interface or abstract class."
  },
  {
    "id": "dotnet-problems-interfaces",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "DO NOT use interfaces if you can use abstract classes. The only reasons to use an interface are: a) you need to \"multiple-inherit\", b) you want structs to implement an abstraction."
  },
  {
    "id": "dotnet-problems-generic-words",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "DO NOT use generic words and terms for type names. For example, do not use names like OperationResponse or DataCollection."
  },
  {
    "id": "dotnet-problems-valid-values",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "YOU SHOULD NOT use parameter types where it's not clear what valid values are supported. For example, do not use strings but only accept certain values in the string."
  },
  {
    "id": "dotnet-problems-empty-types",
    "category": "Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}",
    "text": "DO NOT have empty types (types with no members). [.NET Framework Design Guidelines]: https://docs.microsoft.com/dotnet/standard/design-guidelines/ [.NET Framework Constructor Design]: https://docs.microsoft.com/dotnet/standard/design-guidelines/constructor [Azure Application Configuration service]: https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration [Azure.Core]: https://www.nuget.org/packages/Azure.Core/ [Moq]: https://github.com/moq/moq4 [adparch]: https://github.com/azure/azure-sdk/issues [.NET Standard 2.0]: https://docs.microsoft.com/dotnet/standard/net-standard [azure/azure-sdk-for-net]: https://github.com/azure/azure-sdk-for-net [.NET Target Framework Monikers]: https://learn.microsoft.com/dotnet/standard/frameworks"
  }
]