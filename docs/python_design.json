[
  {
    "id": "python-feature-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "title: \"Python Guidelines: API Design\"\nkeywords: guidelines python\npermalink: python_design.html\nfolder: python\nsidebar: general_sidebar",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe Azure SDK should be designed to enhance the productivity of developers connecting to Azure services. Other qualities (such as completeness, extensibility, and performance) are important but secondary. Productivity is achieved by adhering to the principles described below:\nThe SDK should follow the design guidelines and conventions for the target language. It should feel natural to a developer in the target language.\nWe embrace the ecosystem with its strengths and its flaws.\nWe work with the ecosystem to improve it for all developers.\nClient libraries should be consistent within the language, consistent with the service and consistent between all target languages. In cases of conflict, consistency within the language is the highest priority and consistency between all target languages is the lowest priority.\nService-agnostic concepts such as logging, HTTP communication, and error handling should be consistent. The developer should not have to relearn service-agnostic concepts as they move between client libraries.\nConsistency of terminology between the client library and the service is a good thing that aids in diagnosability.\nAll differences between the service and client library must have a good (articulated) reason for existing, rooted in idiomatic usage rather than whim.\nThe Azure SDK for each target language feels like a single product developed by a single team.\nThere should be feature parity across target languages. This is more important than feature parity with the service.\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Introduction",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Introduction",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Introduction",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Introduction",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Introduction",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Introduction",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Introduction",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Introduction",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Introduction",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Introduction",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Introduction",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Introduction",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Introduction",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Introduction",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Introduction",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Introduction",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Introduction",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Introduction",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Introduction",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Introduction",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Introduction",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Introduction",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Introduction",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Introduction",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Introduction",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Introduction",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Introduction",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Introduction",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Introduction",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Introduction",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Introduction",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Introduction",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Introduction",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Introduction",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Introduction",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Introduction",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Introduction",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Introduction",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Introduction",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Introduction",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Introduction",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Introduction",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Introduction",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Introduction",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Introduction",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Introduction",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Introduction",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Introduction",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Introduction",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Introduction",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Introduction",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Introduction",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Introduction",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Introduction",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Introduction",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Introduction",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Introduction",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Introduction",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Introduction",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Introduction",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Introduction",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Introduction",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Introduction",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Introduction",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Introduction",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Introduction",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Introduction",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Introduction",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Introduction",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Introduction",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Introduction",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Introduction",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Introduction",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Introduction",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Introduction",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Introduction",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Introduction",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Introduction",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Introduction",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Introduction",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Introduction",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Introduction",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Introduction",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Introduction",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Introduction",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Introduction",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Introduction",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Introduction",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Introduction",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Introduction",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Introduction",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Introduction",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Introduction",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Introduction",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Introduction",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Introduction",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Introduction",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Introduction",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Introduction",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Introduction",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Introduction",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Introduction",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Introduction",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Introduction",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Introduction",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Introduction",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Introduction",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Introduction",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Introduction",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Introduction",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Introduction",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Introduction",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Introduction",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Introduction",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Introduction",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Introduction",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Introduction",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Introduction",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Introduction",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Introduction",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Introduction",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Introduction",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Introduction",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Introduction",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Introduction",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Introduction",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Introduction",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Introduction",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Introduction",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe Azure SDK should be designed to enhance the productivity of developers connecting to Azure services. Other qualities (such as completeness, extensibility, and performance) are important but secondary. Productivity is achieved by adhering to the principles described below:\nThe SDK should follow the design guidelines and conventions for the target language. It should feel natural to a developer in the target language.\nWe embrace the ecosystem with its strengths and its flaws.\nWe work with the ecosystem to improve it for all developers.\nClient libraries should be consistent within the language, consistent with the service and consistent between all target languages. In cases of conflict, consistency within the language is the highest priority and consistency between all target languages is the lowest priority.\nService-agnostic concepts such as logging, HTTP communication, and error handling should be consistent. The developer should not have to relearn service-agnostic concepts as they move between client libraries.\nConsistency of terminology between the client library and the service is a good thing that aids in diagnosability.\nAll differences between the service and client library must have a good (articulated) reason for existing, rooted in idiomatic usage rather than whim.\nThe Azure SDK for each target language feels like a single product developed by a single team.\nThere should be feature parity across target languages. This is more important than feature parity with the service.\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Design principles",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Design principles",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Design principles",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Design principles",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Design principles",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Design principles",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Design principles",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Design principles",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Design principles",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Design principles",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Design principles",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Design principles",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Design principles",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Design principles",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Design principles",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Design principles",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Design principles",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Design principles",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Design principles",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Design principles",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Design principles",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Design principles",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Design principles",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Design principles",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Design principles",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Design principles",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Design principles",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Design principles",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Design principles",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Design principles",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Design principles",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Design principles",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Design principles",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Design principles",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Design principles",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Design principles",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Design principles",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Design principles",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Design principles",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Design principles",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Design principles",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Design principles",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Design principles",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Design principles",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Design principles",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Design principles",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Design principles",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Design principles",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Design principles",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Design principles",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Design principles",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Design principles",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Design principles",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Design principles",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Design principles",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Design principles",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Design principles",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Design principles",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Design principles",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Design principles",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Design principles",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Design principles",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Design principles",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Design principles",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Design principles",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Design principles",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Design principles",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Design principles",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Design principles",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Design principles",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Design principles",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Design principles",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Design principles",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Design principles",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Design principles",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Design principles",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Design principles",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Design principles",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Design principles",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Design principles",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Design principles",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Design principles",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Design principles",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Design principles",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Design principles",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Design principles",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Design principles",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Design principles",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Design principles",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Design principles",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Design principles",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Design principles",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Design principles",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Design principles",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Design principles",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Design principles",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Design principles",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Design principles",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Design principles",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Design principles",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Design principles",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Design principles",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Design principles",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Design principles",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Design principles",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Design principles",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Design principles",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Design principles",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Design principles",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Design principles",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Design principles",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Design principles",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Design principles",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Design principles",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Design principles",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Design principles",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Design principles",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Design principles",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Design principles",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Design principles",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Design principles",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Design principles",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Design principles",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Design principles",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Design principles",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Design principles",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Design principles",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Design principles",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Design principles",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\nThe SDK should follow the design guidelines and conventions for the target language. It should feel natural to a developer in the target language.\nWe embrace the ecosystem with its strengths and its flaws.\nWe work with the ecosystem to improve it for all developers.\nClient libraries should be consistent within the language, consistent with the service and consistent between all target languages. In cases of conflict, consistency within the language is the highest priority and consistency between all target languages is the lowest priority.\nService-agnostic concepts such as logging, HTTP communication, and error handling should be consistent. The developer should not have to relearn service-agnostic concepts as they move between client libraries.\nConsistency of terminology between the client library and the service is a good thing that aids in diagnosability.\nAll differences between the service and client library must have a good (articulated) reason for existing, rooted in idiomatic usage rather than whim.\nThe Azure SDK for each target language feels like a single product developed by a single team.\nThere should be feature parity across target languages. This is more important than feature parity with the service.\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Idiomatic",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Idiomatic",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Idiomatic",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Idiomatic",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Idiomatic",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Idiomatic",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Idiomatic",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Idiomatic",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Idiomatic",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Idiomatic",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Idiomatic",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Idiomatic",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Idiomatic",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Idiomatic",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Idiomatic",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Idiomatic",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Idiomatic",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Idiomatic",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Idiomatic",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Idiomatic",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Idiomatic",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Idiomatic",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Idiomatic",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Idiomatic",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Idiomatic",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Idiomatic",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Idiomatic",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Idiomatic",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Idiomatic",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Idiomatic",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Idiomatic",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Idiomatic",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Idiomatic",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Idiomatic",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Idiomatic",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Idiomatic",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Idiomatic",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Idiomatic",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Idiomatic",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Idiomatic",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Idiomatic",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Idiomatic",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Idiomatic",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Idiomatic",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Idiomatic",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Idiomatic",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Idiomatic",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Idiomatic",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Idiomatic",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Idiomatic",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Idiomatic",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Idiomatic",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Idiomatic",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Idiomatic",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Idiomatic",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Idiomatic",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Idiomatic",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Idiomatic",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Idiomatic",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Idiomatic",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Idiomatic",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Idiomatic",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Idiomatic",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Idiomatic",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Idiomatic",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Idiomatic",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Idiomatic",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Idiomatic",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Idiomatic",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Idiomatic",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Idiomatic",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Idiomatic",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Idiomatic",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Idiomatic",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Idiomatic",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Idiomatic",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Idiomatic",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Idiomatic",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Idiomatic",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Idiomatic",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Idiomatic",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Idiomatic",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Idiomatic",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Idiomatic",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Idiomatic",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Idiomatic",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Idiomatic",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Idiomatic",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Idiomatic",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Idiomatic",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Idiomatic",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Idiomatic",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Idiomatic",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Idiomatic",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Idiomatic",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Idiomatic",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Idiomatic",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Idiomatic",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Idiomatic",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Idiomatic",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Idiomatic",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Idiomatic",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Idiomatic",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Idiomatic",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Idiomatic",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Idiomatic",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Idiomatic",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Idiomatic",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Idiomatic",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Idiomatic",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Idiomatic",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Idiomatic",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Idiomatic",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Idiomatic",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Idiomatic",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Idiomatic",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Idiomatic",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Idiomatic",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Idiomatic",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Idiomatic",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Idiomatic",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Idiomatic",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Idiomatic",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Idiomatic",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Idiomatic",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Idiomatic",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Idiomatic",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Idiomatic",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Idiomatic",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\nClient libraries should be consistent within the language, consistent with the service and consistent between all target languages. In cases of conflict, consistency within the language is the highest priority and consistency between all target languages is the lowest priority.\nService-agnostic concepts such as logging, HTTP communication, and error handling should be consistent. The developer should not have to relearn service-agnostic concepts as they move between client libraries.\nConsistency of terminology between the client library and the service is a good thing that aids in diagnosability.\nAll differences between the service and client library must have a good (articulated) reason for existing, rooted in idiomatic usage rather than whim.\nThe Azure SDK for each target language feels like a single product developed by a single team.\nThere should be feature parity across target languages. This is more important than feature parity with the service.\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Consistent",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Consistent",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Consistent",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Consistent",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Consistent",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Consistent",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Consistent",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Consistent",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Consistent",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Consistent",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Consistent",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Consistent",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Consistent",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Consistent",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Consistent",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Consistent",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Consistent",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Consistent",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Consistent",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Consistent",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Consistent",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Consistent",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Consistent",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Consistent",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Consistent",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Consistent",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Consistent",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Consistent",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Consistent",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Consistent",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Consistent",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Consistent",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Consistent",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Consistent",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Consistent",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Consistent",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Consistent",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Consistent",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Consistent",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Consistent",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Consistent",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Consistent",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Consistent",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Consistent",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Consistent",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Consistent",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Consistent",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Consistent",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Consistent",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Consistent",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Consistent",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Consistent",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Consistent",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Consistent",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Consistent",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Consistent",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Consistent",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Consistent",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Consistent",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Consistent",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Consistent",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Consistent",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Consistent",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Consistent",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Consistent",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Consistent",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Consistent",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Consistent",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Consistent",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Consistent",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Consistent",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Consistent",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Consistent",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Consistent",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Consistent",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Consistent",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Consistent",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Consistent",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Consistent",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Consistent",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Consistent",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Consistent",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Consistent",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Consistent",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Consistent",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Consistent",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Consistent",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Consistent",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Consistent",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Consistent",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Consistent",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Consistent",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Consistent",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Consistent",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Consistent",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Consistent",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Consistent",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Consistent",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Consistent",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Consistent",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Consistent",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Consistent",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Consistent",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Consistent",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Consistent",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Consistent",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Consistent",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Consistent",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Consistent",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Consistent",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Consistent",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Consistent",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Consistent",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Consistent",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Consistent",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Consistent",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Consistent",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Consistent",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Consistent",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Consistent",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Consistent",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Consistent",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Consistent",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Consistent",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Consistent",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Consistent",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Consistent",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Consistent",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Consistent",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Approachable",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Approachable",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Approachable",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Approachable",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Approachable",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Approachable",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Approachable",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Approachable",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Approachable",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Approachable",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Approachable",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Approachable",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Approachable",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Approachable",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Approachable",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Approachable",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Approachable",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Approachable",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Approachable",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Approachable",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Approachable",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Approachable",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Approachable",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Approachable",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Approachable",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Approachable",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Approachable",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Approachable",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Approachable",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Approachable",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Approachable",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Approachable",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Approachable",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Approachable",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Approachable",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Approachable",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Approachable",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Approachable",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Approachable",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Approachable",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Approachable",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Approachable",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Approachable",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Approachable",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Approachable",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Approachable",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Approachable",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Approachable",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Approachable",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Approachable",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Approachable",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Approachable",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Approachable",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Approachable",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Approachable",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Approachable",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Approachable",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Approachable",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Approachable",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Approachable",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Approachable",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Approachable",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Approachable",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Approachable",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Approachable",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Approachable",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Approachable",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Approachable",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Approachable",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Approachable",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Approachable",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Approachable",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Approachable",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Approachable",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Approachable",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Approachable",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Approachable",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Approachable",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Approachable",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Approachable",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Approachable",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Approachable",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Approachable",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Approachable",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Approachable",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Approachable",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Approachable",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Approachable",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Approachable",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Approachable",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Approachable",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Approachable",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Approachable",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Approachable",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Approachable",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Approachable",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Approachable",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Approachable",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Approachable",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Approachable",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Approachable",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Approachable",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Approachable",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Approachable",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Approachable",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Approachable",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Approachable",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Approachable",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Approachable",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Approachable",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Approachable",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Approachable",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Approachable",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Approachable",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Approachable",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Approachable",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Approachable",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Approachable",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Approachable",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Approachable",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Approachable",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Approachable",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Approachable",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Approachable",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Approachable",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Approachable",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Approachable",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Approachable",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Approachable",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Diagnosable",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Diagnosable",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Diagnosable",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Diagnosable",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Diagnosable",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Diagnosable",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Diagnosable",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Diagnosable",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Diagnosable",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Diagnosable",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Diagnosable",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Diagnosable",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Diagnosable",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Diagnosable",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Diagnosable",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Diagnosable",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Diagnosable",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Diagnosable",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Diagnosable",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Diagnosable",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Diagnosable",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Diagnosable",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Diagnosable",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Diagnosable",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Diagnosable",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Diagnosable",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Diagnosable",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Diagnosable",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Diagnosable",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Diagnosable",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Diagnosable",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Diagnosable",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Diagnosable",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Diagnosable",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Diagnosable",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Diagnosable",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Diagnosable",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Diagnosable",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Diagnosable",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Diagnosable",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Diagnosable",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Diagnosable",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Diagnosable",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Diagnosable",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Diagnosable",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Diagnosable",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Diagnosable",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Diagnosable",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Diagnosable",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Diagnosable",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Diagnosable",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Diagnosable",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Diagnosable",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Diagnosable",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Diagnosable",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Diagnosable",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Diagnosable",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Diagnosable",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Diagnosable",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Diagnosable",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Diagnosable",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Diagnosable",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Diagnosable",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Diagnosable",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Diagnosable",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Diagnosable",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Diagnosable",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Diagnosable",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Diagnosable",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Diagnosable",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Diagnosable",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Diagnosable",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Diagnosable",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Diagnosable",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Diagnosable",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Diagnosable",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Diagnosable",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Diagnosable",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Diagnosable",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Diagnosable",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Diagnosable",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Diagnosable",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Diagnosable",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Diagnosable",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Diagnosable",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Diagnosable",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Diagnosable",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Diagnosable",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Diagnosable",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Diagnosable",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Diagnosable",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Diagnosable",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Diagnosable",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Diagnosable",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Diagnosable",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Diagnosable",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Diagnosable",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Diagnosable",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Diagnosable",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Diagnosable",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Diagnosable",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Diagnosable",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Diagnosable",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Diagnosable",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Diagnosable",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Diagnosable",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Diagnosable",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Diagnosable",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Diagnosable",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Diagnosable",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Diagnosable",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Diagnosable",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Diagnosable",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Diagnosable",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Diagnosable",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Diagnosable",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Diagnosable",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Diagnosable",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Diagnosable",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Diagnosable",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Diagnosable",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Diagnosable",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Diagnosable",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Diagnosable",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Diagnosable",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Diagnosable",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Diagnosable",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Diagnosable",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Diagnosable",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Dependable",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Dependable",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Dependable",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Dependable",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Dependable",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Dependable",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Dependable",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Dependable",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Dependable",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Dependable",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Dependable",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Dependable",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Dependable",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Dependable",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Dependable",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Dependable",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Dependable",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Dependable",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Dependable",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Dependable",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Dependable",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Dependable",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Dependable",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Dependable",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Dependable",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Dependable",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Dependable",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Dependable",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Dependable",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Dependable",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Dependable",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Dependable",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Dependable",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Dependable",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Dependable",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Dependable",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Dependable",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Dependable",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Dependable",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Dependable",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Dependable",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Dependable",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Dependable",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Dependable",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Dependable",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Dependable",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Dependable",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Dependable",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Dependable",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Dependable",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Dependable",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Dependable",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Dependable",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Dependable",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Dependable",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Dependable",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Dependable",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Dependable",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Dependable",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Dependable",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Dependable",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Dependable",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Dependable",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Dependable",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Dependable",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Dependable",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Dependable",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Dependable",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Dependable",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Dependable",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Dependable",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Dependable",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Dependable",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Dependable",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Dependable",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Dependable",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Dependable",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Dependable",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Dependable",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Dependable",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Dependable",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Dependable",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Dependable",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Dependable",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Dependable",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Dependable",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Dependable",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Dependable",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Dependable",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Dependable",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Dependable",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Dependable",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Dependable",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Dependable",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Dependable",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Dependable",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Dependable",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Dependable",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Dependable",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Dependable",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Dependable",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Dependable",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Dependable",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Dependable",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Dependable",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Dependable",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Dependable",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Dependable",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Dependable",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Dependable",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Dependable",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Dependable",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Dependable",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Dependable",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Dependable",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Dependable",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Dependable",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Dependable",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Dependable",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Dependable",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Dependable",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Dependable",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Dependable",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Dependable",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Dependable",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Dependable",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Dependable",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Dependable",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Dependable",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "General guidelines",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "General guidelines",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "General guidelines",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "General guidelines",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "General guidelines",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "General guidelines",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "General guidelines",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "General guidelines",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "General guidelines",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "General guidelines",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "General guidelines",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "General guidelines",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "General guidelines",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "General guidelines",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "General guidelines",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "General guidelines",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "General guidelines",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "General guidelines",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "General guidelines",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "General guidelines",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "General guidelines",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "General guidelines",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "General guidelines",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "General guidelines",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "General guidelines",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "General guidelines",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "General guidelines",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "General guidelines",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "General guidelines",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "General guidelines",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "General guidelines",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "General guidelines",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "General guidelines",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "General guidelines",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "General guidelines",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "General guidelines",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "General guidelines",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "General guidelines",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "General guidelines",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "General guidelines",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "General guidelines",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "General guidelines",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "General guidelines",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "General guidelines",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "General guidelines",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "General guidelines",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "General guidelines",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "General guidelines",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "General guidelines",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "General guidelines",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "General guidelines",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "General guidelines",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "General guidelines",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "General guidelines",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "General guidelines",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "General guidelines",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "General guidelines",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "General guidelines",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "General guidelines",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "General guidelines",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "General guidelines",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "General guidelines",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "General guidelines",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "General guidelines",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "General guidelines",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "General guidelines",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "General guidelines",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "General guidelines",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "General guidelines",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "General guidelines",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "General guidelines",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "General guidelines",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "General guidelines",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "General guidelines",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "General guidelines",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "General guidelines",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "General guidelines",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "General guidelines",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "General guidelines",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "General guidelines",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "General guidelines",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "General guidelines",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "General guidelines",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "General guidelines",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "General guidelines",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "General guidelines",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "General guidelines",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "General guidelines",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "General guidelines",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "General guidelines",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "General guidelines",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "General guidelines",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "General guidelines",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "General guidelines",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "General guidelines",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "General guidelines",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "General guidelines",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "General guidelines",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "General guidelines",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "General guidelines",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "General guidelines",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "General guidelines",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "General guidelines",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "General guidelines",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "General guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "General guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "General guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "General guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "General guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "General guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "General guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "General guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "General guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "General guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "General guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Non-HTTP based services",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Non-HTTP based services",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Non-HTTP based services",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Non-HTTP based services",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Non-HTTP based services",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Non-HTTP based services",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Non-HTTP based services",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Non-HTTP based services",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Non-HTTP based services",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Non-HTTP based services",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Non-HTTP based services",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Non-HTTP based services",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Non-HTTP based services",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Non-HTTP based services",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Non-HTTP based services",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Non-HTTP based services",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Non-HTTP based services",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Non-HTTP based services",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Non-HTTP based services",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Non-HTTP based services",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Non-HTTP based services",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Non-HTTP based services",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Non-HTTP based services",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Non-HTTP based services",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Non-HTTP based services",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Non-HTTP based services",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Non-HTTP based services",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Non-HTTP based services",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Non-HTTP based services",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Non-HTTP based services",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Non-HTTP based services",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Non-HTTP based services",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Non-HTTP based services",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Non-HTTP based services",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Non-HTTP based services",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Non-HTTP based services",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Non-HTTP based services",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Non-HTTP based services",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Non-HTTP based services",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Non-HTTP based services",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Non-HTTP based services",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Non-HTTP based services",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Non-HTTP based services",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Non-HTTP based services",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Non-HTTP based services",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Non-HTTP based services",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Non-HTTP based services",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Non-HTTP based services",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Non-HTTP based services",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Non-HTTP based services",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Non-HTTP based services",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Non-HTTP based services",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Non-HTTP based services",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Non-HTTP based services",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Non-HTTP based services",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Non-HTTP based services",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Non-HTTP based services",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Non-HTTP based services",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Non-HTTP based services",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Non-HTTP based services",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Non-HTTP based services",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Non-HTTP based services",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Non-HTTP based services",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Non-HTTP based services",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Non-HTTP based services",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Non-HTTP based services",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Non-HTTP based services",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Non-HTTP based services",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Non-HTTP based services",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Non-HTTP based services",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Non-HTTP based services",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Non-HTTP based services",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Non-HTTP based services",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Non-HTTP based services",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Non-HTTP based services",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Non-HTTP based services",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Non-HTTP based services",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Non-HTTP based services",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Non-HTTP based services",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Non-HTTP based services",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Non-HTTP based services",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Non-HTTP based services",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Non-HTTP based services",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Non-HTTP based services",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Non-HTTP based services",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Non-HTTP based services",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Non-HTTP based services",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Non-HTTP based services",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Non-HTTP based services",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Non-HTTP based services",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Non-HTTP based services",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Non-HTTP based services",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Non-HTTP based services",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Non-HTTP based services",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Non-HTTP based services",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-general-version-support",
    "category": "Supported python versions",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Supported python versions",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Supported python versions",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Supported python versions",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Supported python versions",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Supported python versions",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Supported python versions",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Supported python versions",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Supported python versions",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Supported python versions",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Supported python versions",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Supported python versions",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Supported python versions",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Supported python versions",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Supported python versions",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Supported python versions",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Supported python versions",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Supported python versions",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Supported python versions",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Supported python versions",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Supported python versions",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Supported python versions",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Supported python versions",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Supported python versions",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Supported python versions",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Supported python versions",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Supported python versions",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Supported python versions",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Supported python versions",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Supported python versions",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Supported python versions",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Supported python versions",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Supported python versions",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Supported python versions",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Supported python versions",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Supported python versions",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Supported python versions",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Supported python versions",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Supported python versions",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Supported python versions",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Supported python versions",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Supported python versions",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supported python versions",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supported python versions",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supported python versions",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supported python versions",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supported python versions",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supported python versions",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supported python versions",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supported python versions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supported python versions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supported python versions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supported python versions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supported python versions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supported python versions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supported python versions",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supported python versions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supported python versions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supported python versions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supported python versions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supported python versions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supported python versions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supported python versions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supported python versions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supported python versions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supported python versions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supported python versions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supported python versions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supported python versions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supported python versions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supported python versions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supported python versions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supported python versions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supported python versions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supported python versions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supported python versions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supported python versions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supported python versions",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supported python versions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supported python versions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supported python versions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supported python versions",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supported python versions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supported python versions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supported python versions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supported python versions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supported python versions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supported python versions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supported python versions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supported python versions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supported python versions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supported python versions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supported python versions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supported python versions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supported python versions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supported python versions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supported python versions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supported python versions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supported python versions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supported python versions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supported python versions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supported python versions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supported python versions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supported python versions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supported python versions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supported python versions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supported python versions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supported python versions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supported python versions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supported python versions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supported python versions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supported python versions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supported python versions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supported python versions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Azure SDK API Design",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Azure SDK API Design",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Azure SDK API Design",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Azure SDK API Design",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Azure SDK API Design",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Azure SDK API Design",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Azure SDK API Design",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Azure SDK API Design",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Azure SDK API Design",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Azure SDK API Design",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Azure SDK API Design",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Azure SDK API Design",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Azure SDK API Design",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Azure SDK API Design",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Azure SDK API Design",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Azure SDK API Design",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Azure SDK API Design",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Azure SDK API Design",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Azure SDK API Design",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Azure SDK API Design",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Azure SDK API Design",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Azure SDK API Design",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Azure SDK API Design",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Azure SDK API Design",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Azure SDK API Design",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Azure SDK API Design",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Azure SDK API Design",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Azure SDK API Design",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Azure SDK API Design",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Azure SDK API Design",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Azure SDK API Design",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Azure SDK API Design",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Azure SDK API Design",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Azure SDK API Design",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Azure SDK API Design",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Azure SDK API Design",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Azure SDK API Design",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Azure SDK API Design",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Azure SDK API Design",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Azure SDK API Design",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Azure SDK API Design",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Azure SDK API Design",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Azure SDK API Design",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Azure SDK API Design",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Azure SDK API Design",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Azure SDK API Design",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Azure SDK API Design",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Azure SDK API Design",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Azure SDK API Design",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Azure SDK API Design",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Azure SDK API Design",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Azure SDK API Design",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Azure SDK API Design",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Azure SDK API Design",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Azure SDK API Design",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK API Design",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK API Design",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK API Design",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK API Design",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK API Design",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK API Design",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK API Design",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK API Design",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK API Design",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK API Design",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK API Design",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK API Design",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK API Design",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK API Design",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK API Design",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK API Design",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK API Design",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK API Design",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK API Design",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK API Design",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK API Design",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK API Design",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK API Design",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK API Design",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK API Design",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK API Design",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK API Design",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK API Design",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK API Design",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK API Design",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK API Design",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK API Design",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK API Design",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK API Design",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK API Design",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK API Design",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK API Design",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK API Design",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK API Design",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Service client",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Service client",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Service client",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n# Yes\nclass CosmosClient: ...\n\n# No\nclass CosmosProxy: ...\n\n# No\nclass CosmosUrl: ...\n\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Service client",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Service client",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Service client",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Service client",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Service client",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Service client",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Service client",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Service client",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Service client",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Service client",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Service client",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Service client",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Service client",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Service client",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Service client",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Service client",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Service client",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Service client",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Service client",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Service client",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Service client",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Service client",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service client",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service client",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service client",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service client",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service client",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service client",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service client",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service client",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service client",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service client",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service client",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service client",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service client",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service client",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service client",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service client",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service client",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service client",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service client",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service client",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service client",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service client",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service client",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service client",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service client",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service client",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service client",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service client",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service client",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service client",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service client",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service client",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service client",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service client",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service client",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service client",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service client",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service client",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service client",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service client",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service client",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service client",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service client",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service client",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service client",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service client",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service client",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service client",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service client",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service client",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service client",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service client",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service client",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service client",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service client",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service client",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service client",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service client",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service client",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service client",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service client",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service client",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service client",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service client",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service client",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service client",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service client",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service client",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service client",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service client",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service client",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service client",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service client",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service client",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service client",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service client",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service client",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service client",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service client",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service client",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service client",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service client",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service client",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service client",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service client",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service client",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service client",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service client",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service client",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service client",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service client",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service client",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service client",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service client",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service client",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service client",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Constructors and factory methods",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Constructors and factory methods",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Constructors and factory methods",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Constructors and factory methods",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Constructors and factory methods",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Constructors and factory methods",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Constructors and factory methods",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Constructors and factory methods",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Constructors and factory methods",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Constructors and factory methods",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Constructors and factory methods",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Constructors and factory methods",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Constructors and factory methods",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Constructors and factory methods",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Constructors and factory methods",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Constructors and factory methods",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Constructors and factory methods",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Constructors and factory methods",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Constructors and factory methods",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Constructors and factory methods",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Constructors and factory methods",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Constructors and factory methods",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Constructors and factory methods",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Constructors and factory methods",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Constructors and factory methods",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Constructors and factory methods",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Constructors and factory methods",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Constructors and factory methods",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Constructors and factory methods",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Constructors and factory methods",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Constructors and factory methods",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Constructors and factory methods",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Constructors and factory methods",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Constructors and factory methods",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Constructors and factory methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Constructors and factory methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Constructors and factory methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Constructors and factory methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Constructors and factory methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Constructors and factory methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Constructors and factory methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Constructors and factory methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Constructors and factory methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Constructors and factory methods",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Constructors and factory methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Constructors and factory methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Constructors and factory methods",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Constructors and factory methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Constructors and factory methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Constructors and factory methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Constructors and factory methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Constructors and factory methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Constructors and factory methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Constructors and factory methods",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Constructors and factory methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Constructors and factory methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Constructors and factory methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Constructors and factory methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Constructors and factory methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Constructors and factory methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Constructors and factory methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Constructors and factory methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Constructors and factory methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Constructors and factory methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Constructors and factory methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Constructors and factory methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Constructors and factory methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Constructors and factory methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Constructors and factory methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Constructors and factory methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Constructors and factory methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Constructors and factory methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Constructors and factory methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Constructors and factory methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Constructors and factory methods",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Constructors and factory methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Constructors and factory methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Constructors and factory methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Constructors and factory methods",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Constructors and factory methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Constructors and factory methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Constructors and factory methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Constructors and factory methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Constructors and factory methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Constructors and factory methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Constructors and factory methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Constructors and factory methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Constructors and factory methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Constructors and factory methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Constructors and factory methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Constructors and factory methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Constructors and factory methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Constructors and factory methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Constructors and factory methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Constructors and factory methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Constructors and factory methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Constructors and factory methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Constructors and factory methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Constructors and factory methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Constructors and factory methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Constructors and factory methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Constructors and factory methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Constructors and factory methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Constructors and factory methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Constructors and factory methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Constructors and factory methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Constructors and factory methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Constructors and factory methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Constructors and factory methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Constructors and factory methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Constructors and factory methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Constructors and factory methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-constructor-form",
    "category": "Client configuration",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Client configuration",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Client configuration",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n# Change default number of retries to 18 and overall timeout to 2s.\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Client configuration",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Client configuration",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n    @classmethod\n    def _parse_connection_string(cls, connection_string): ...\n\n    @classmethod\n    def from_connection_string(cls, connection_string, **kwargs):\n        endpoint, credential = cls._parse_connection_string(connection_string)\n        return cls(endpoint, credential, **kwargs)\n\n```\n\n```python\n{% include_relative _includes/example_client.py %}\n\n```"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Client configuration",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Client configuration",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Client configuration",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Client configuration",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Client configuration",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Client configuration",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Client configuration",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Client configuration",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Client configuration",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Client configuration",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Client configuration",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Client configuration",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Client configuration",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Client configuration",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Client configuration",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Client configuration",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Client configuration",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Client configuration",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Client configuration",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Client configuration",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Client configuration",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Client configuration",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Client configuration",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Client configuration",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Client configuration",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Client configuration",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Client configuration",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Client configuration",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Client configuration",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Client configuration",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Client configuration",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Client configuration",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Client configuration",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Client configuration",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Client configuration",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Client configuration",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Client configuration",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Client configuration",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Client configuration",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Client configuration",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Client configuration",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Client configuration",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Client configuration",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Client configuration",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Client configuration",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Client configuration",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Client configuration",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Client configuration",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Client configuration",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Client configuration",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Client configuration",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Client configuration",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Client configuration",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Client configuration",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Client configuration",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Client configuration",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Client configuration",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Client configuration",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Client configuration",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Client configuration",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Client configuration",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Client configuration",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Client configuration",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Client configuration",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Client configuration",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Client configuration",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Client configuration",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Client configuration",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Client configuration",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Client configuration",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Client configuration",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Client configuration",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Client configuration",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Client configuration",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Client configuration",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Client configuration",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Client configuration",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Client configuration",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Client configuration",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Client configuration",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Client configuration",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Client configuration",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Client configuration",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Client configuration",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Client configuration",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Client configuration",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Client configuration",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Client configuration",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Client configuration",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Client configuration",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Client configuration",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Client configuration",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Client configuration",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Client configuration",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Client configuration",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Client configuration",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Client configuration",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Client configuration",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Client configuration",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Client configuration",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Client configuration",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Client configuration",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Client configuration",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Client configuration",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Client configuration",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Client configuration",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Client configuration",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Client configuration",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Client configuration",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Client configuration",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Client configuration",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Client configuration",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Client configuration",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Client configuration",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Client configuration",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Client configuration",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Client configuration",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Client configuration",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Specifying the Service Version",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\n# By default, use the latest supported API version\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\n# ...but allow the caller to specify a specific API version as welll\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Specifying the Service Version",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Specifying the Service Version",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Specifying the Service Version",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Specifying the Service Version",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Specifying the Service Version",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Specifying the Service Version",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Specifying the Service Version",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Specifying the Service Version",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Specifying the Service Version",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Specifying the Service Version",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Specifying the Service Version",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Specifying the Service Version",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Specifying the Service Version",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Specifying the Service Version",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Specifying the Service Version",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Specifying the Service Version",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Specifying the Service Version",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Specifying the Service Version",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Specifying the Service Version",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Specifying the Service Version",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Specifying the Service Version",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Specifying the Service Version",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Specifying the Service Version",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Specifying the Service Version",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Specifying the Service Version",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Specifying the Service Version",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Specifying the Service Version",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Specifying the Service Version",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Specifying the Service Version",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Specifying the Service Version",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Specifying the Service Version",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Specifying the Service Version",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Specifying the Service Version",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Specifying the Service Version",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Specifying the Service Version",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Specifying the Service Version",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Specifying the Service Version",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Specifying the Service Version",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Specifying the Service Version",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Specifying the Service Version",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Specifying the Service Version",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Specifying the Service Version",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Specifying the Service Version",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Specifying the Service Version",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Specifying the Service Version",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Specifying the Service Version",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Specifying the Service Version",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Specifying the Service Version",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Specifying the Service Version",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Specifying the Service Version",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Specifying the Service Version",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Specifying the Service Version",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Specifying the Service Version",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Specifying the Service Version",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Specifying the Service Version",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Specifying the Service Version",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Specifying the Service Version",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Specifying the Service Version",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Specifying the Service Version",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Specifying the Service Version",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Specifying the Service Version",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Specifying the Service Version",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Specifying the Service Version",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Specifying the Service Version",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Specifying the Service Version",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Specifying the Service Version",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Specifying the Service Version",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Specifying the Service Version",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Specifying the Service Version",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Specifying the Service Version",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Specifying the Service Version",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Specifying the Service Version",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Specifying the Service Version",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Specifying the Service Version",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Specifying the Service Version",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Specifying the Service Version",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Specifying the Service Version",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Specifying the Service Version",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Specifying the Service Version",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Specifying the Service Version",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Specifying the Service Version",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Specifying the Service Version",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Specifying the Service Version",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Specifying the Service Version",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Specifying the Service Version",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Specifying the Service Version",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Specifying the Service Version",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Specifying the Service Version",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Specifying the Service Version",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Specifying the Service Version",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Specifying the Service Version",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Specifying the Service Version",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Specifying the Service Version",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Specifying the Service Version",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Specifying the Service Version",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Specifying the Service Version",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Specifying the Service Version",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Specifying the Service Version",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Specifying the Service Version",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Specifying the Service Version",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Specifying the Service Version",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Specifying the Service Version",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Specifying the Service Version",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Specifying the Service Version",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Specifying the Service Version",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Additional constructor parameters",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Additional constructor parameters",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Additional constructor parameters",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Additional constructor parameters",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Additional constructor parameters",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Additional constructor parameters",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Additional constructor parameters",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Additional constructor parameters",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Additional constructor parameters",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Additional constructor parameters",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Additional constructor parameters",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Additional constructor parameters",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Additional constructor parameters",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Additional constructor parameters",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Additional constructor parameters",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Additional constructor parameters",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Additional constructor parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Additional constructor parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Additional constructor parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Additional constructor parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Additional constructor parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Additional constructor parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Additional constructor parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Additional constructor parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Additional constructor parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Additional constructor parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Additional constructor parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Additional constructor parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Additional constructor parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Additional constructor parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Additional constructor parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Additional constructor parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Additional constructor parameters",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Additional constructor parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Additional constructor parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Additional constructor parameters",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Additional constructor parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Additional constructor parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Additional constructor parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Additional constructor parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Additional constructor parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Additional constructor parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Additional constructor parameters",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Additional constructor parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Additional constructor parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Additional constructor parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Additional constructor parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Additional constructor parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Additional constructor parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Additional constructor parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Additional constructor parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Additional constructor parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Additional constructor parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Additional constructor parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Additional constructor parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Additional constructor parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Additional constructor parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Additional constructor parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Additional constructor parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Additional constructor parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Additional constructor parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Additional constructor parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Additional constructor parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Additional constructor parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Additional constructor parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Additional constructor parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Additional constructor parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Additional constructor parameters",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Additional constructor parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Additional constructor parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Additional constructor parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Additional constructor parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Additional constructor parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Additional constructor parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Additional constructor parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Additional constructor parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Additional constructor parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Additional constructor parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Additional constructor parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Additional constructor parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Additional constructor parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Additional constructor parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Additional constructor parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Additional constructor parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Additional constructor parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Additional constructor parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Additional constructor parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Additional constructor parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Additional constructor parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Additional constructor parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Additional constructor parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Additional constructor parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Additional constructor parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Additional constructor parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Additional constructor parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Additional constructor parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Additional constructor parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Additional constructor parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Additional constructor parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Additional constructor parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Additional constructor parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Client immutability",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Client immutability",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Client immutability",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Client immutability",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Client immutability",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Client immutability",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Client immutability",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Client immutability",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Client immutability",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Client immutability",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Client immutability",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Client immutability",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Client immutability",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Client immutability",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Client immutability",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Client immutability",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Client immutability",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Client immutability",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Client immutability",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Client immutability",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Client immutability",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Client immutability",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Client immutability",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Client immutability",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Client immutability",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Client immutability",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Client immutability",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Client immutability",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Client immutability",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Client immutability",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Client immutability",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Client immutability",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Client immutability",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Client immutability",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Client immutability",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Client immutability",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Client immutability",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Client immutability",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Client immutability",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Client immutability",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Client immutability",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Client immutability",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Client immutability",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Client immutability",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Client immutability",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Client immutability",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Client immutability",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Client immutability",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Client immutability",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Client immutability",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Client immutability",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Client immutability",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Client immutability",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Client immutability",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Client immutability",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Client immutability",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Client immutability",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Client immutability",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Client immutability",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Client immutability",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Client immutability",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Client immutability",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Client immutability",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Client immutability",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Client immutability",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Client immutability",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Client immutability",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Client immutability",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Client immutability",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Client immutability",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Client immutability",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Client immutability",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Client immutability",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Client immutability",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Client immutability",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Client immutability",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Client immutability",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Client immutability",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Client immutability",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Client immutability",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Client immutability",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Client immutability",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Client immutability",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Client immutability",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Client immutability",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Client immutability",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Client immutability",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Client immutability",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Client immutability",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Client immutability",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Client immutability",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Client immutability",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Client immutability",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Client immutability",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Client immutability",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Client immutability",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Client immutability",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Client immutability",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Client immutability",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Client immutability",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Client immutability",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Client immutability",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Client immutability",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Client immutability",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Client immutability",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Client immutability",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Client immutability",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Client immutability",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Client immutability",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Client immutability",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Client immutability",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Client immutability",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-verbs",
    "category": "Service methods",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Service methods",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Service methods",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Service methods",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Service methods",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Service methods",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Service methods",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Service methods",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Service methods",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service methods",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service methods",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service methods",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service methods",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service methods",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service methods",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service methods",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service methods",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service methods",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service methods",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service methods",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service methods",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service methods",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service methods",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service methods",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service methods",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service methods",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service methods",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service methods",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service methods",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service methods",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-verbs",
    "category": "Naming",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Naming",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Naming",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Naming",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Naming",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Naming",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Naming",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Naming",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Naming",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Naming",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Naming",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Naming",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Naming",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Naming",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Naming",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Naming",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Naming",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Naming",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Naming",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Naming",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Naming",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Naming",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Naming",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Naming",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Naming",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Naming",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Naming",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Naming",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Naming",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Naming",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Naming",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Naming",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Naming",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Naming",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Naming",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Naming",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Naming",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Naming",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Naming",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Naming",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Naming",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Naming",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Naming",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Naming",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Naming",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Naming",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Naming",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Naming",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Naming",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Naming",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Naming",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Naming",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Naming",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Naming",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Naming",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Naming",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Naming",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Naming",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Naming",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Naming",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Naming",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Naming",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Naming",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Naming",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Naming",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Naming",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Naming",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Naming",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Naming",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Naming",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Naming",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Naming",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Naming",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Naming",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Naming",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Naming",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Naming",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Naming",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Naming",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Naming",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Naming",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Naming",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Naming",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Naming",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Naming",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Naming",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Naming",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Naming",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Naming",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Naming",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Naming",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Naming",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Naming",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Naming",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Naming",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Naming",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Naming",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Naming",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Naming",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Naming",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Naming",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Naming",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Naming",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Naming",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Naming",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Naming",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Naming",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Naming",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Naming",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Naming",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Naming",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Return types",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Return types",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n# Yes\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\n# No\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Return types",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n# Yes\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\n# No\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Return types",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Return types",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Return types",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Return types",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Return types",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Return types",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Return types",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Return types",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Return types",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Return types",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Return types",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Return types",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Return types",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Return types",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Return types",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Return types",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Return types",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Return types",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Return types",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Return types",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Return types",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Return types",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Return types",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Return types",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Return types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Return types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Return types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Return types",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Return types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Return types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Return types",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Return types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Return types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Return types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Return types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Return types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Return types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Return types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Return types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Return types",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Return types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Return types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Return types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Return types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Return types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Return types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Return types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Return types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Return types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Return types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Return types",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Return types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Return types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Return types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Return types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Return types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Return types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Return types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Return types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Return types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Return types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Return types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Return types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Return types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Return types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Return types",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Return types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Return types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Return types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Return types",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Return types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Return types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Return types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Return types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Return types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Return types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Return types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Return types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Return types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Return types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Return types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Return types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Return types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Return types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Return types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Return types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Return types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Return types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Return types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Return types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Return types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Return types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Return types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Return types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Return types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Return types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Return types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Return types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Return types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Return types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Return types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Return types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Return types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Return types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Cancellation",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Cancellation",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Cancellation",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Cancellation",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Cancellation",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Cancellation",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Cancellation",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Cancellation",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Cancellation",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Cancellation",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Cancellation",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Cancellation",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Cancellation",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Cancellation",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Cancellation",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Cancellation",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Cancellation",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Cancellation",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Cancellation",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Cancellation",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Cancellation",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Cancellation",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Cancellation",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Cancellation",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Cancellation",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Cancellation",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Cancellation",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Cancellation",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Cancellation",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Cancellation",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Cancellation",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Cancellation",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Cancellation",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Cancellation",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Cancellation",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Cancellation",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Cancellation",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Cancellation",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Cancellation",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Cancellation",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Cancellation",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Cancellation",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Cancellation",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Cancellation",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Cancellation",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Cancellation",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Cancellation",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Cancellation",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Cancellation",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Cancellation",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Cancellation",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Cancellation",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Cancellation",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Cancellation",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Cancellation",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Cancellation",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Cancellation",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Cancellation",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Cancellation",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Cancellation",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Cancellation",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Cancellation",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Cancellation",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Cancellation",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Cancellation",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Cancellation",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Cancellation",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Cancellation",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Cancellation",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Cancellation",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Cancellation",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Cancellation",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Cancellation",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Cancellation",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Cancellation",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Cancellation",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Cancellation",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Cancellation",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Cancellation",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Cancellation",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Cancellation",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Cancellation",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Cancellation",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Cancellation",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Cancellation",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Cancellation",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Cancellation",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Cancellation",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Cancellation",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Cancellation",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Cancellation",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Cancellation",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Cancellation",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Cancellation",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Cancellation",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Cancellation",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Cancellation",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Cancellation",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Cancellation",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Cancellation",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Cancellation",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Cancellation",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Cancellation",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Cancellation",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service Method Parameters",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service Method Parameters",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service Method Parameters",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n# Set the default number of retries to 18 and timeout to 2s for this client instance.\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\n# Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)\nclient.do_stuff(timeout=32)\n\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service Method Parameters",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service Method Parameters",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service Method Parameters",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service Method Parameters",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service Method Parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service Method Parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service Method Parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service Method Parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service Method Parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service Method Parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service Method Parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service Method Parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service Method Parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service Method Parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service Method Parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service Method Parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service Method Parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service Method Parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service Method Parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service Method Parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service Method Parameters",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service Method Parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service Method Parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service Method Parameters",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service Method Parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service Method Parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service Method Parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service Method Parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service Method Parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service Method Parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service Method Parameters",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service Method Parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service Method Parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service Method Parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service Method Parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service Method Parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service Method Parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service Method Parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service Method Parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service Method Parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service Method Parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service Method Parameters",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service Method Parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service Method Parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service Method Parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service Method Parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service Method Parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service Method Parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service Method Parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service Method Parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service Method Parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service Method Parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service Method Parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service Method Parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service Method Parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service Method Parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service Method Parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service Method Parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service Method Parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service Method Parameters",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service Method Parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service Method Parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service Method Parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service Method Parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service Method Parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service Method Parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service Method Parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service Method Parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service Method Parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service Method Parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service Method Parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service Method Parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service Method Parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service Method Parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service Method Parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service Method Parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service Method Parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service Method Parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service Method Parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service Method Parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service Method Parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service Method Parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service Method Parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service Method Parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service Method Parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service Method Parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service Method Parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service Method Parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service Method Parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service Method Parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service Method Parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service Method Parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service Method Parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Parameter validation",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n# No:\ndef get_thing(name: str) -&gt; str:\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n# Yes:\ndef get_thing(name: str) -&gt; str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https://&lt;host&gt;/things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Parameter validation",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Parameter validation",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Parameter validation",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Parameter validation",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Parameter validation",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Parameter validation",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Parameter validation",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Parameter validation",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Parameter validation",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Parameter validation",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Parameter validation",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Parameter validation",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Parameter validation",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Parameter validation",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Parameter validation",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Parameter validation",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Parameter validation",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Parameter validation",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Parameter validation",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Parameter validation",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Parameter validation",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Parameter validation",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Parameter validation",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Parameter validation",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Parameter validation",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Parameter validation",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Parameter validation",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Parameter validation",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Parameter validation",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Parameter validation",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Parameter validation",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Parameter validation",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Parameter validation",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Parameter validation",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Parameter validation",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Parameter validation",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Parameter validation",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Parameter validation",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Parameter validation",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Parameter validation",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Parameter validation",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Parameter validation",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Parameter validation",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Parameter validation",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Parameter validation",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Parameter validation",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Parameter validation",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Parameter validation",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Parameter validation",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Parameter validation",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Parameter validation",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Parameter validation",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Parameter validation",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Parameter validation",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Parameter validation",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Parameter validation",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Parameter validation",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Parameter validation",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Parameter validation",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Parameter validation",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Parameter validation",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Parameter validation",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Parameter validation",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Parameter validation",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Parameter validation",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Parameter validation",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Parameter validation",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Parameter validation",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Parameter validation",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Parameter validation",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Parameter validation",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Parameter validation",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Parameter validation",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Parameter validation",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Parameter validation",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Parameter validation",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Parameter validation",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Parameter validation",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Parameter validation",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Parameter validation",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Parameter validation",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Parameter validation",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Parameter validation",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Parameter validation",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Parameter validation",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Parameter validation",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Parameter validation",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Parameter validation",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Parameter validation",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Parameter validation",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Parameter validation",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Parameter validation",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Parameter validation",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Parameter validation",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Parameter validation",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Parameter validation",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Parameter validation",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Parameter validation",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-args",
    "category": "Common service operation parameters",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Common service operation parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n# Yes:\nclass Thing:\n\n    def __init__(self, name, size):\n        self.name = name\n        self.size = size\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Common service operation parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, size, description):\n        self.name = name\n        self.size = size\n        self.description = description\n\n    def __repr__(self):\n        return json.dumps({\n            \"name\": self.name, \"size\": self.size, \"description\": self.description\n        })[:1024]\n\nclass Client:\n\n    def update_thing(self, name=None, size=None, thing=None): ...\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n# Will send a request to the service to update the model's size to 4713 and description to 'Updated'\nclient.update_thing(name='hello', size=4713, thing=thing)\n\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Common service operation parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Common service operation parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Common service operation parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Common service operation parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Common service operation parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Common service operation parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Common service operation parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Common service operation parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Common service operation parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Common service operation parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Common service operation parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Common service operation parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Common service operation parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Common service operation parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Common service operation parameters",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Common service operation parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Common service operation parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Common service operation parameters",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Common service operation parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Common service operation parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Common service operation parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Common service operation parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Common service operation parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Common service operation parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Common service operation parameters",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Common service operation parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Common service operation parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Common service operation parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Common service operation parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Common service operation parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Common service operation parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Common service operation parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Common service operation parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Common service operation parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Common service operation parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Common service operation parameters",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Common service operation parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Common service operation parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Common service operation parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Common service operation parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Common service operation parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Common service operation parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Common service operation parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Common service operation parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Common service operation parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Common service operation parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Common service operation parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Common service operation parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Common service operation parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Common service operation parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Common service operation parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Common service operation parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Common service operation parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Common service operation parameters",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Common service operation parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Common service operation parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Common service operation parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Common service operation parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Common service operation parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Common service operation parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Common service operation parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Common service operation parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Common service operation parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Common service operation parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Common service operation parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Common service operation parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Common service operation parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Common service operation parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Common service operation parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Common service operation parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Common service operation parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Common service operation parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Common service operation parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Common service operation parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Common service operation parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Common service operation parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Common service operation parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Common service operation parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Common service operation parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Common service operation parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Common service operation parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Common service operation parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Common service operation parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Common service operation parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Common service operation parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Common service operation parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Common service operation parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Methods returning collections (paging)",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\n# List all things - paging happens transparently in the\n# background.\nfor thing in client.list_things():\n    print(thing)\n\n# The protocol also allows you to list things by page...\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\n# No - don't pass in the continuation token directly to the method...\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\n# Yes - provide a continuation_token to in the `by_page` method...\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Methods returning collections (paging)",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Methods returning collections (paging)",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Methods returning collections (paging)",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Methods returning collections (paging)",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Methods returning collections (paging)",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Methods returning collections (paging)",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Methods returning collections (paging)",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Methods returning collections (paging)",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Methods returning collections (paging)",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Methods returning collections (paging)",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Methods returning collections (paging)",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Methods returning collections (paging)",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Methods returning collections (paging)",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Methods returning collections (paging)",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Methods returning collections (paging)",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Methods returning collections (paging)",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Methods returning collections (paging)",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Methods returning collections (paging)",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Methods returning collections (paging)",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Methods returning collections (paging)",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Methods returning collections (paging)",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Methods returning collections (paging)",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Methods returning collections (paging)",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Methods returning collections (paging)",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Methods returning collections (paging)",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Methods returning collections (paging)",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Methods returning collections (paging)",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Methods returning collections (paging)",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Methods returning collections (paging)",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Methods returning collections (paging)",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Methods returning collections (paging)",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Methods returning collections (paging)",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Methods returning collections (paging)",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Methods returning collections (paging)",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Methods returning collections (paging)",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Methods returning collections (paging)",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Methods returning collections (paging)",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Methods returning collections (paging)",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Methods returning collections (paging)",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Methods returning collections (paging)",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Methods returning collections (paging)",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Methods returning collections (paging)",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Methods returning collections (paging)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Methods returning collections (paging)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Methods returning collections (paging)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Methods returning collections (paging)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Methods returning collections (paging)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Methods returning collections (paging)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Methods returning collections (paging)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Methods returning collections (paging)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Methods returning collections (paging)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Methods returning collections (paging)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Methods returning collections (paging)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Methods returning collections (paging)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Methods invoking long running operations",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Methods invoking long running operations",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Methods invoking long running operations",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Methods invoking long running operations",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Methods invoking long running operations",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Methods invoking long running operations",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Methods invoking long running operations",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Methods invoking long running operations",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Methods invoking long running operations",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Methods invoking long running operations",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Methods invoking long running operations",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Methods invoking long running operations",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Methods invoking long running operations",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Methods invoking long running operations",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Methods invoking long running operations",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Methods invoking long running operations",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Methods invoking long running operations",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Methods invoking long running operations",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Methods invoking long running operations",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Methods invoking long running operations",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Methods invoking long running operations",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Methods invoking long running operations",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Methods invoking long running operations",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Methods invoking long running operations",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Methods invoking long running operations",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Methods invoking long running operations",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Methods invoking long running operations",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Methods invoking long running operations",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Methods invoking long running operations",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Methods invoking long running operations",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Methods invoking long running operations",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Methods invoking long running operations",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Methods invoking long running operations",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Methods invoking long running operations",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Methods invoking long running operations",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Methods invoking long running operations",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Methods invoking long running operations",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Methods invoking long running operations",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Methods invoking long running operations",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Methods invoking long running operations",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Methods invoking long running operations",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Methods invoking long running operations",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Methods invoking long running operations",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Methods invoking long running operations",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Methods invoking long running operations",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Methods invoking long running operations",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Methods invoking long running operations",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Methods invoking long running operations",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Methods invoking long running operations",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Methods invoking long running operations",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Methods invoking long running operations",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Methods invoking long running operations",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Methods invoking long running operations",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Methods invoking long running operations",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Methods invoking long running operations",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Methods invoking long running operations",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Methods invoking long running operations",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Methods invoking long running operations",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Methods invoking long running operations",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Methods invoking long running operations",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Methods invoking long running operations",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Methods invoking long running operations",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Methods invoking long running operations",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Methods invoking long running operations",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Methods invoking long running operations",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Methods invoking long running operations",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Methods invoking long running operations",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Methods invoking long running operations",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Methods invoking long running operations",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Methods invoking long running operations",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Methods invoking long running operations",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Methods invoking long running operations",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Methods invoking long running operations",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Methods invoking long running operations",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Methods invoking long running operations",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Methods invoking long running operations",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Methods invoking long running operations",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-method-conditional-request",
    "category": "Conditional request methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Conditional request methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\n    def __init__(self, name, etag):\n        self.name = name\n        self.etag = etag\n\nthing = client.get_thing('theName')\n\n# Uses the etag from the retrieved thing instance....\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\n# Uses the explicitly provided etag.\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Conditional request methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Conditional request methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Conditional request methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Conditional request methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Conditional request methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Conditional request methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Conditional request methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Conditional request methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Conditional request methods",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Conditional request methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Conditional request methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Conditional request methods",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Conditional request methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Conditional request methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Conditional request methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Conditional request methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Conditional request methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Conditional request methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Conditional request methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Conditional request methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Conditional request methods",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Conditional request methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Conditional request methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Conditional request methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Conditional request methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Conditional request methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Conditional request methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Conditional request methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Conditional request methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Conditional request methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Conditional request methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Conditional request methods",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Conditional request methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Conditional request methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Conditional request methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Conditional request methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Conditional request methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Conditional request methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Conditional request methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Conditional request methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Conditional request methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Conditional request methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Conditional request methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Conditional request methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Conditional request methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Conditional request methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Conditional request methods",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Conditional request methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Conditional request methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Conditional request methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Conditional request methods",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Conditional request methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Conditional request methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Conditional request methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Conditional request methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Conditional request methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Conditional request methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Conditional request methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Conditional request methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Conditional request methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Conditional request methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Conditional request methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Conditional request methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Conditional request methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Conditional request methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Conditional request methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Conditional request methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Conditional request methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Conditional request methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Conditional request methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Conditional request methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Conditional request methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Conditional request methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Conditional request methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Conditional request methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Conditional request methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Conditional request methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Conditional request methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Conditional request methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Conditional request methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Conditional request methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Conditional request methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Conditional request methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Conditional request methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Conditional request methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Hierarchical clients",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Hierarchical clients",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    __init__(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    __init__(self, url, credentials, **kwargs) ...\n\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Hierarchical clients",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Hierarchical clients",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Hierarchical clients",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Hierarchical clients",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Hierarchical clients",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Hierarchical clients",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Hierarchical clients",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Hierarchical clients",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Hierarchical clients",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Hierarchical clients",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Hierarchical clients",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Hierarchical clients",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Hierarchical clients",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Hierarchical clients",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Hierarchical clients",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Hierarchical clients",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Hierarchical clients",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Hierarchical clients",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Hierarchical clients",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Hierarchical clients",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Hierarchical clients",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Hierarchical clients",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Hierarchical clients",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Hierarchical clients",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Hierarchical clients",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Hierarchical clients",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Hierarchical clients",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Hierarchical clients",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Hierarchical clients",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Hierarchical clients",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Hierarchical clients",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Hierarchical clients",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Hierarchical clients",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Hierarchical clients",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Hierarchical clients",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Hierarchical clients",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Hierarchical clients",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Hierarchical clients",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Hierarchical clients",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Hierarchical clients",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Hierarchical clients",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Hierarchical clients",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Hierarchical clients",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Hierarchical clients",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Hierarchical clients",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Hierarchical clients",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Hierarchical clients",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Hierarchical clients",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Hierarchical clients",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Hierarchical clients",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Hierarchical clients",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Hierarchical clients",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Hierarchical clients",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Hierarchical clients",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Hierarchical clients",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Hierarchical clients",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Hierarchical clients",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Hierarchical clients",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Hierarchical clients",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Hierarchical clients",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Hierarchical clients",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Hierarchical clients",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Hierarchical clients",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Hierarchical clients",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Hierarchical clients",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Hierarchical clients",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Hierarchical clients",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Hierarchical clients",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Hierarchical clients",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Hierarchical clients",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Hierarchical clients",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Hierarchical clients",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Hierarchical clients",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Hierarchical clients",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Hierarchical clients",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Hierarchical clients",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Hierarchical clients",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Hierarchical clients",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supporting types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supporting types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supporting types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supporting types",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supporting types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supporting types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supporting types",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supporting types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supporting types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supporting types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supporting types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supporting types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supporting types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supporting types",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supporting types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supporting types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supporting types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supporting types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supporting types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supporting types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supporting types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supporting types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supporting types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supporting types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supporting types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supporting types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supporting types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supporting types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supporting types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supporting types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supporting types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supporting types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supporting types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supporting types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supporting types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supporting types",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supporting types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supporting types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supporting types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supporting types",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supporting types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supporting types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supporting types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supporting types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supporting types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supporting types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supporting types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supporting types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supporting types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supporting types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supporting types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supporting types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supporting types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supporting types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supporting types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supporting types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supporting types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supporting types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supporting types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supporting types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supporting types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supporting types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supporting types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supporting types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supporting types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supporting types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supporting types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supporting types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supporting types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supporting types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supporting types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supporting types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Model types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Model types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Model types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Model types",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Model types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n# An example of a model type.\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n    :ivar name: The name of the setting\n    :vartype name: str\n    :ivar value: The value of the setting\n    :vartype value: object\n    \"\"\"\n\n    def __init__(self, name: str, value: object):\n        self.name = name\n        self.value = value\n\n    def __repr__(self) -&gt; str:\n        return json.dumps(self.__dict__)[:1024]\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Model types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Model types",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Model types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Model types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Model types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Model types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Model types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Model types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Model types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Model types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Model types",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Model types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Model types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Model types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Model types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Model types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Model types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Model types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Model types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Model types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Model types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Model types",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Model types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Model types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Model types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Model types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Model types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Model types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Model types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Model types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Model types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Model types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Model types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Model types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Model types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Model types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Model types",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Model types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Model types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Model types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Model types",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Model types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Model types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Model types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Model types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Model types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Model types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Model types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Model types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Model types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Model types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Model types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Model types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Model types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Model types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Model types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Model types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Model types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Model types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Model types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Model types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Model types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Model types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Model types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Model types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Model types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Model types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Model types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Model types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Model types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Model types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Model types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Model types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Model types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Model types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-models-enum-string",
    "category": "Enumerations",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Enumerations",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Enumerations",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Enumerations",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Enumerations",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Enumerations",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Enumerations",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Enumerations",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Enumerations",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Enumerations",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Enumerations",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Enumerations",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Enumerations",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Enumerations",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Enumerations",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Enumerations",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Enumerations",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Enumerations",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Enumerations",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Enumerations",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Enumerations",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Enumerations",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Enumerations",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Enumerations",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Enumerations",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Enumerations",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Enumerations",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Enumerations",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Enumerations",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Enumerations",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Enumerations",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Enumerations",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Enumerations",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Enumerations",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Enumerations",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Enumerations",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Enumerations",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Enumerations",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Enumerations",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Enumerations",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Enumerations",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Enumerations",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Enumerations",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Enumerations",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Enumerations",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Enumerations",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Enumerations",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Enumerations",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Enumerations",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Enumerations",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Enumerations",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Enumerations",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Enumerations",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Enumerations",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Enumerations",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Enumerations",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Enumerations",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Enumerations",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Enumerations",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Enumerations",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Enumerations",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Enumerations",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Enumerations",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Enumerations",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Enumerations",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Enumerations",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Enumerations",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Enumerations",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Enumerations",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Enumerations",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Enumerations",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Enumerations",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Enumerations",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Enumerations",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Enumerations",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Exceptions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Exceptions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Exceptions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Exceptions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Exceptions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Exceptions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Exceptions",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Exceptions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Exceptions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Exceptions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Exceptions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Exceptions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Exceptions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Exceptions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Exceptions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Exceptions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Exceptions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Exceptions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Exceptions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Exceptions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Exceptions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Exceptions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Exceptions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Exceptions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Exceptions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Exceptions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Exceptions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Exceptions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Exceptions",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Exceptions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Exceptions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Exceptions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Exceptions",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Exceptions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Exceptions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Exceptions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Exceptions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Exceptions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Exceptions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Exceptions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Exceptions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Exceptions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Exceptions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Exceptions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Exceptions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Exceptions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Exceptions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Exceptions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Exceptions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Exceptions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Exceptions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Exceptions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Exceptions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Exceptions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Exceptions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Exceptions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Exceptions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Exceptions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Exceptions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Exceptions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Exceptions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Exceptions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Exceptions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Exceptions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Exceptions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Authentication",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Authentication",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Authentication",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Authentication",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Authentication",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Authentication",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Authentication",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Authentication",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Authentication",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Authentication",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Authentication",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Authentication",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Authentication",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Authentication",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Authentication",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Authentication",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Authentication",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Authentication",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Authentication",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Authentication",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Authentication",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Authentication",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Authentication",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Authentication",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Authentication",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Authentication",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Authentication",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Authentication",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Authentication",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Authentication",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Authentication",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Authentication",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Authentication",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Authentication",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Authentication",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Authentication",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Authentication",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Authentication",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Authentication",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Authentication",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Authentication",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Authentication",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Authentication",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Authentication",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Authentication",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Authentication",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Authentication",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Authentication",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Authentication",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Authentication",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Authentication",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Authentication",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Authentication",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Authentication",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Authentication",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Authentication",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Authentication",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Authentication",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Authentication",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Authentication",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Authentication",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Authentication",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Authentication",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Authentication",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Namespaces",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Namespaces",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Namespaces",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Namespaces",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Namespaces",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Namespaces",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Namespaces",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Namespaces",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Namespaces",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Namespaces",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Namespaces",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Namespaces",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Namespaces",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Namespaces",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Namespaces",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Namespaces",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Namespaces",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Namespaces",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Namespaces",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Namespaces",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Namespaces",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Namespaces",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Namespaces",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Namespaces",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Namespaces",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Namespaces",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Namespaces",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Namespaces",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Namespaces",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Namespaces",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Namespaces",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Namespaces",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Namespaces",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Namespaces",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Namespaces",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Namespaces",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Namespaces",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Namespaces",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Namespaces",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Namespaces",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Namespaces",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Namespaces",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Namespaces",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Namespaces",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Namespaces",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Namespaces",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Namespaces",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Namespaces",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Namespaces",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Namespaces",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Namespaces",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Namespaces",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Namespaces",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Namespaces",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Namespaces",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Namespaces",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Namespaces",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Namespaces",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Example Namespaces",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Example Namespaces",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Example Namespaces",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Example Namespaces",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Example Namespaces",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Example Namespaces",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Example Namespaces",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Example Namespaces",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Example Namespaces",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Example Namespaces",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Example Namespaces",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Example Namespaces",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Example Namespaces",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Example Namespaces",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Example Namespaces",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Example Namespaces",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Example Namespaces",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Example Namespaces",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Example Namespaces",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Example Namespaces",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Example Namespaces",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Example Namespaces",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Example Namespaces",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Example Namespaces",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Example Namespaces",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Example Namespaces",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Example Namespaces",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Example Namespaces",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Example Namespaces",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Example Namespaces",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Example Namespaces",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Example Namespaces",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Example Namespaces",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Example Namespaces",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Example Namespaces",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Example Namespaces",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Example Namespaces",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Example Namespaces",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Example Namespaces",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Example Namespaces",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Example Namespaces",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Example Namespaces",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Example Namespaces",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Example Namespaces",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Example Namespaces",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Example Namespaces",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Example Namespaces",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Example Namespaces",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Example Namespaces",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Example Namespaces",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Example Namespaces",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Example Namespaces",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Example Namespaces",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Example Namespaces",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Example Namespaces",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Example Namespaces",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Example Namespaces",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Async support",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Async support",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Async support",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Async support",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Async support",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Async support",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Async support",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Async support",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Async support",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Async support",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Async support",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Async support",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Async support",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Async support",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Async support",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Async support",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Async support",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Async support",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Async support",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Async support",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Async support",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Async support",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Async support",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Async support",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Async support",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Async support",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Async support",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Async support",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Async support",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Async support",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Async support",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Async support",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Async support",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Async support",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Async support",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Async support",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Async support",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Async support",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Async support",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Async support",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Async support",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Async support",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Async support",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Async support",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Async support",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Async support",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Async support",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Async support",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Async support",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Async support",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Async support",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Async support",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Async support",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Async support",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Async support",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK distribution packages",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK distribution packages",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK distribution packages",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK distribution packages",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK distribution packages",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK distribution packages",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK distribution packages",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK distribution packages",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK distribution packages",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK distribution packages",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK distribution packages",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK distribution packages",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK distribution packages",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK distribution packages",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK distribution packages",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK distribution packages",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK distribution packages",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK distribution packages",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK distribution packages",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK distribution packages",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK distribution packages",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK distribution packages",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK distribution packages",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK distribution packages",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Packaging",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Packaging",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Packaging",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Packaging",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Packaging",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Packaging",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Packaging",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Packaging",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Packaging",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Packaging",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Packaging",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Packaging",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Packaging",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Packaging",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Packaging",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Packaging",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Packaging",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Packaging",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Packaging",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Packaging",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Packaging",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Packaging",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Packaging",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Packaging",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Packaging",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Packaging",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Packaging",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Packaging",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Packaging",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Packaging",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Packaging",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Packaging",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Packaging",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Packaging",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Packaging",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Packaging",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Packaging",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Packaging",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Packaging",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Packaging",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Packaging",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Packaging",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Packaging",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Packaging",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Packaging",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Packaging",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Packaging",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service-specific common library code",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service-specific common library code",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service-specific common library code",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service-specific common library code",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service-specific common library code",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service-specific common library code",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service-specific common library code",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service-specific common library code",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service-specific common library code",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service-specific common library code",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service-specific common library code",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service-specific common library code",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service-specific common library code",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service-specific common library code",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service-specific common library code",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service-specific common library code",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service-specific common library code",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service-specific common library code",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service-specific common library code",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service-specific common library code",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service-specific common library code",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service-specific common library code",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service-specific common library code",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service-specific common library code",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service-specific common library code",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service-specific common library code",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service-specific common library code",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service-specific common library code",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service-specific common library code",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service-specific common library code",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service-specific common library code",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service-specific common library code",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service-specific common library code",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service-specific common library code",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service-specific common library code",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service-specific common library code",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service-specific common library code",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service-specific common library code",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-versioning-semver",
    "category": "Package Versioning",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Package Versioning",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Package Versioning",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Package Versioning",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Package Versioning",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Package Versioning",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Package Versioning",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Package Versioning",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Package Versioning",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Package Versioning",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Package Versioning",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Package Versioning",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Package Versioning",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Package Versioning",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Package Versioning",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Package Versioning",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Package Versioning",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Package Versioning",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Package Versioning",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Package Versioning",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Package Versioning",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Package Versioning",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Package Versioning",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Package Versioning",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Package Versioning",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Package Versioning",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Package Versioning",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Package Versioning",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Package Versioning",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Package Versioning",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Package Versioning",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Package Versioning",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Package Versioning",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Package Versioning",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Dependencies",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Dependencies",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Dependencies",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Dependencies",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Dependencies",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Dependencies",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Dependencies",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Dependencies",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Dependencies",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Dependencies",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Dependencies",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Dependencies",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Dependencies",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Dependencies",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Dependencies",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Dependencies",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Dependencies",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Dependencies",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Dependencies",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Dependencies",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Dependencies",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Dependencies",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Dependencies",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Dependencies",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Dependencies",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-native-approval",
    "category": "Binary extensions (native code)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Binary extensions (native code)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Binary extensions (native code)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Binary extensions (native code)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Binary extensions (native code)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Binary extensions (native code)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Binary extensions (native code)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Binary extensions (native code)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Binary extensions (native code)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Binary extensions (native code)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Binary extensions (native code)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Binary extensions (native code)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Binary extensions (native code)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Binary extensions (native code)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Binary extensions (native code)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Binary extensions (native code)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Binary extensions (native code)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Binary extensions (native code)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Docstrings",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Docstrings",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Docstrings",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(*args, **kwargs):\n    \"Calls `request` with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", *args, **kwargs)\n\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Docstrings",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Docstrings",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Docstrings",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Docstrings",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Docstrings",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Docstrings",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Docstrings",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Docstrings",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Docstrings",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Docstrings",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Docstrings",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Docstrings",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Docstrings",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Docstrings",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Docstrings",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-snippets-include",
    "category": "Code snippets",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Code snippets",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Code snippets",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Code snippets",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Code snippets",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Code snippets",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Code snippets",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Code snippets",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Code snippets",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Code snippets",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Code snippets",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Code snippets",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Code snippets",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Code snippets",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Code snippets",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Code snippets",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Repository Guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Repository Guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Repository Guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Repository Guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Repository Guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Repository Guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Repository Guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Repository Guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Repository Guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Repository Guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Repository Guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Repository Guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Documentation style",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Documentation style",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Documentation style",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Documentation style",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Documentation style",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Documentation style",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Documentation style",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Documentation style",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Documentation style",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Documentation style",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Documentation style",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Documentation style",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Samples",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Samples",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Samples",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Samples",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Samples",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Samples",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Samples",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Samples",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  }
]