[
  {
    "id": "python-feature-support",
    "category": "General guidelines",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "These guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Please contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "General guidelines",
    "text": "DO support Python 3.7+."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Your API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "General guidelines",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "General guidelines",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "General guidelines",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "General guidelines",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "General guidelines",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "General guidelines",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "General guidelines",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "General guidelines",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "General guidelines",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "General guidelines",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "General guidelines",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "General guidelines",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "General guidelines",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "General guidelines",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "General guidelines",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "General guidelines",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "General guidelines",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "General guidelines",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "General guidelines",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "General guidelines",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "General guidelines",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "General guidelines",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "General guidelines",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "General guidelines",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "General guidelines",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "General guidelines",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "General guidelines",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "General guidelines",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "General guidelines",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "General guidelines",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "General guidelines",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "General guidelines",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "General guidelines",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "General guidelines",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "General guidelines",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "General guidelines",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "General guidelines",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "General guidelines",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "General guidelines",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "General guidelines",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "General guidelines",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "General guidelines",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "General guidelines",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "General guidelines",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "General guidelines",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "General guidelines",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "General guidelines",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "General guidelines",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "General guidelines",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "General guidelines",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "General guidelines",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "General guidelines",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "General guidelines",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "General guidelines",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "General guidelines",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "General guidelines",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "General guidelines",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "General guidelines",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "General guidelines",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "General guidelines",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "General guidelines",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "General guidelines",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "General guidelines",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "General guidelines",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "General guidelines",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "General guidelines",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "General guidelines",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "General guidelines",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "General guidelines",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "General guidelines",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "General guidelines",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "General guidelines",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "General guidelines",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "General guidelines",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "General guidelines",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "General guidelines",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "General guidelines",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "General guidelines",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "General guidelines",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "General guidelines",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "General guidelines",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "General guidelines",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "General guidelines",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "General guidelines",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "General guidelines",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "General guidelines",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "General guidelines",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "General guidelines",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "General guidelines",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "General guidelines",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "General guidelines",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "General guidelines",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "General guidelines",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "General guidelines",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "General guidelines",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "General guidelines",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "General guidelines",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "General guidelines",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "General guidelines",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "General guidelines",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "General guidelines",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "General guidelines",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "General guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "General guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "General guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "General guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "General guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "General guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "General guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "General guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "General guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "General guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "General guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "General guidelines",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "These guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Please contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Non-HTTP based services",
    "text": "DO support Python 3.7+."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Your API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Non-HTTP based services",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Non-HTTP based services",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Non-HTTP based services",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Non-HTTP based services",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Non-HTTP based services",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Non-HTTP based services",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Non-HTTP based services",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Non-HTTP based services",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Non-HTTP based services",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Non-HTTP based services",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Non-HTTP based services",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Non-HTTP based services",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Non-HTTP based services",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Non-HTTP based services",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Non-HTTP based services",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Non-HTTP based services",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Non-HTTP based services",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Non-HTTP based services",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Non-HTTP based services",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Non-HTTP based services",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Non-HTTP based services",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Non-HTTP based services",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Non-HTTP based services",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Non-HTTP based services",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Non-HTTP based services",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Non-HTTP based services",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Non-HTTP based services",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Non-HTTP based services",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Non-HTTP based services",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Non-HTTP based services",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Non-HTTP based services",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Non-HTTP based services",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Non-HTTP based services",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Non-HTTP based services",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Non-HTTP based services",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Non-HTTP based services",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Non-HTTP based services",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Non-HTTP based services",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Non-HTTP based services",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Non-HTTP based services",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Non-HTTP based services",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Non-HTTP based services",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Non-HTTP based services",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Non-HTTP based services",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Non-HTTP based services",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Non-HTTP based services",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Non-HTTP based services",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Non-HTTP based services",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Non-HTTP based services",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Non-HTTP based services",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Non-HTTP based services",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Non-HTTP based services",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Non-HTTP based services",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Non-HTTP based services",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Non-HTTP based services",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Non-HTTP based services",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Non-HTTP based services",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Non-HTTP based services",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Non-HTTP based services",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Non-HTTP based services",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Non-HTTP based services",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Non-HTTP based services",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Non-HTTP based services",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Non-HTTP based services",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Non-HTTP based services",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Non-HTTP based services",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Non-HTTP based services",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Non-HTTP based services",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Non-HTTP based services",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Non-HTTP based services",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Non-HTTP based services",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Non-HTTP based services",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Non-HTTP based services",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Non-HTTP based services",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Non-HTTP based services",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Non-HTTP based services",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Non-HTTP based services",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Non-HTTP based services",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Non-HTTP based services",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Non-HTTP based services",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Non-HTTP based services",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Non-HTTP based services",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Non-HTTP based services",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Non-HTTP based services",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Non-HTTP based services",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Non-HTTP based services",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Non-HTTP based services",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Non-HTTP based services",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Non-HTTP based services",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Non-HTTP based services",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Non-HTTP based services",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Non-HTTP based services",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Non-HTTP based services",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Non-HTTP based services",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Non-HTTP based services",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-general-version-support",
    "category": "Supported python versions",
    "text": "DO support Python 3.7+."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Your API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Supported python versions",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Supported python versions",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Supported python versions",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Supported python versions",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Supported python versions",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Supported python versions",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Supported python versions",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Supported python versions",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Supported python versions",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Supported python versions",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Supported python versions",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Supported python versions",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Supported python versions",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Supported python versions",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Supported python versions",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Supported python versions",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Supported python versions",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Supported python versions",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Supported python versions",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Supported python versions",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Supported python versions",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Supported python versions",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Supported python versions",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Supported python versions",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Supported python versions",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Supported python versions",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Supported python versions",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Supported python versions",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Supported python versions",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Supported python versions",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Supported python versions",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Supported python versions",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Supported python versions",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Supported python versions",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Supported python versions",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Supported python versions",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Supported python versions",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Supported python versions",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Supported python versions",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Supported python versions",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Supported python versions",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supported python versions",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supported python versions",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supported python versions",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supported python versions",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supported python versions",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supported python versions",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supported python versions",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supported python versions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supported python versions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supported python versions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supported python versions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supported python versions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supported python versions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supported python versions",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supported python versions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supported python versions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supported python versions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supported python versions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supported python versions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supported python versions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supported python versions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supported python versions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supported python versions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supported python versions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supported python versions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supported python versions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supported python versions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supported python versions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supported python versions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supported python versions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supported python versions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supported python versions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supported python versions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supported python versions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supported python versions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supported python versions",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supported python versions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supported python versions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supported python versions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supported python versions",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supported python versions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supported python versions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supported python versions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supported python versions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supported python versions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supported python versions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supported python versions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supported python versions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supported python versions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supported python versions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supported python versions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supported python versions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supported python versions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supported python versions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supported python versions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supported python versions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supported python versions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supported python versions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supported python versions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supported python versions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supported python versions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supported python versions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supported python versions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supported python versions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supported python versions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supported python versions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supported python versions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supported python versions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supported python versions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supported python versions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supported python versions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supported python versions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Supported python versions",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Your API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Azure SDK API Design",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Azure SDK API Design",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Azure SDK API Design",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Azure SDK API Design",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Azure SDK API Design",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Azure SDK API Design",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Azure SDK API Design",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Azure SDK API Design",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Azure SDK API Design",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Azure SDK API Design",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Azure SDK API Design",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Azure SDK API Design",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Azure SDK API Design",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Azure SDK API Design",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Azure SDK API Design",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Azure SDK API Design",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Azure SDK API Design",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Azure SDK API Design",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Azure SDK API Design",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Azure SDK API Design",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Azure SDK API Design",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Azure SDK API Design",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Azure SDK API Design",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Azure SDK API Design",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Azure SDK API Design",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Azure SDK API Design",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Azure SDK API Design",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Azure SDK API Design",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Azure SDK API Design",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Azure SDK API Design",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Azure SDK API Design",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Azure SDK API Design",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Azure SDK API Design",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Azure SDK API Design",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Azure SDK API Design",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Azure SDK API Design",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Azure SDK API Design",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Azure SDK API Design",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Azure SDK API Design",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Azure SDK API Design",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Azure SDK API Design",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Azure SDK API Design",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Azure SDK API Design",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Azure SDK API Design",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Azure SDK API Design",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Azure SDK API Design",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Azure SDK API Design",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Azure SDK API Design",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Azure SDK API Design",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Azure SDK API Design",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Azure SDK API Design",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Azure SDK API Design",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Azure SDK API Design",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Azure SDK API Design",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Azure SDK API Design",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK API Design",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK API Design",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK API Design",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK API Design",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK API Design",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK API Design",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK API Design",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK API Design",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK API Design",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK API Design",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK API Design",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK API Design",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK API Design",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK API Design",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK API Design",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK API Design",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK API Design",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK API Design",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK API Design",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK API Design",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK API Design",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK API Design",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK API Design",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK API Design",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK API Design",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK API Design",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK API Design",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK API Design",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK API Design",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK API Design",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK API Design",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK API Design",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK API Design",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK API Design",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK API Design",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK API Design",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK API Design",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK API Design",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK API Design",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Azure SDK API Design",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Service client",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Service client",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Service client",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Service client",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Service client",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Service client",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Service client",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Service client",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Service client",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Service client",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Service client",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Service client",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Service client",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Service client",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Service client",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Service client",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Service client",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Service client",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Service client",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Service client",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Service client",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Service client",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Service client",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Service client",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Service client",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service client",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service client",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service client",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service client",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service client",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service client",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service client",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service client",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service client",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service client",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service client",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service client",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service client",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service client",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service client",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service client",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service client",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service client",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service client",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service client",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service client",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service client",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service client",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service client",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service client",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service client",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service client",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service client",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service client",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service client",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service client",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service client",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service client",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service client",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service client",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service client",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service client",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service client",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service client",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service client",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service client",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service client",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service client",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service client",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service client",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service client",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service client",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service client",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service client",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service client",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service client",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service client",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service client",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service client",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service client",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service client",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service client",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service client",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service client",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service client",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service client",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service client",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service client",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service client",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service client",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service client",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service client",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service client",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service client",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service client",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Service client",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service client",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service client",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service client",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service client",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service client",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service client",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service client",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service client",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service client",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service client",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service client",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service client",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service client",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service client",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service client",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service client",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service client",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service client",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service client",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service client",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service client",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service client",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service client",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service client",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service client",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service client",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Service client",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class CosmosClient: ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Yes",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Yes",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Yes",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Yes",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Yes",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Yes",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Yes",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Yes",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Yes",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Yes",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Yes",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Yes",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Yes",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Yes",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Yes",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Yes",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Yes",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Yes",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Yes",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Yes",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "class CosmosProxy: ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "No",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "No",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "No",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "No",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "No",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "No",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "No",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": null,
    "category": "No",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "No",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "No",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "No",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "No",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "No",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "No",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "No",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "No",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "No",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "No",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "No",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "No",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "No",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "No",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "No",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "No",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "No",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "No",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "No",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "No",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "class CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "No",
    "text": "DO make the service client immutable. See the Client Immutability section for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "No",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "No",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "No",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "No",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "No",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "No",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": null,
    "category": "No",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "No",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "No",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "No",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "No",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "No",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "No",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "No",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "No",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "No",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "No",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "No",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "No",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "No",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "No",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "No",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "No",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "No",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "No",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "No",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "No",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Only the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Constructors and factory methods",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Constructors and factory methods",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Constructors and factory methods",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Constructors and factory methods",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Constructors and factory methods",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Constructors and factory methods",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Constructors and factory methods",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Constructors and factory methods",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Constructors and factory methods",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Constructors and factory methods",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Constructors and factory methods",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Constructors and factory methods",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Constructors and factory methods",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Constructors and factory methods",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Constructors and factory methods",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Constructors and factory methods",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Constructors and factory methods",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Constructors and factory methods",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Constructors and factory methods",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Constructors and factory methods",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Constructors and factory methods",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Constructors and factory methods",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Constructors and factory methods",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Constructors and factory methods",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Constructors and factory methods",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Constructors and factory methods",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Constructors and factory methods",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Constructors and factory methods",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Constructors and factory methods",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Constructors and factory methods",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Constructors and factory methods",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Constructors and factory methods",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Constructors and factory methods",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Constructors and factory methods",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Constructors and factory methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Constructors and factory methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Constructors and factory methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Constructors and factory methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Constructors and factory methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Constructors and factory methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Constructors and factory methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Constructors and factory methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Constructors and factory methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Constructors and factory methods",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Constructors and factory methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Constructors and factory methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Constructors and factory methods",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Constructors and factory methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Constructors and factory methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Constructors and factory methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Constructors and factory methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Constructors and factory methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Constructors and factory methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Constructors and factory methods",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Constructors and factory methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Constructors and factory methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Constructors and factory methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Constructors and factory methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Constructors and factory methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Constructors and factory methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Constructors and factory methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Constructors and factory methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Constructors and factory methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Constructors and factory methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Constructors and factory methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Constructors and factory methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Constructors and factory methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Constructors and factory methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Constructors and factory methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Constructors and factory methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Constructors and factory methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Constructors and factory methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Constructors and factory methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Constructors and factory methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Constructors and factory methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Constructors and factory methods",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Constructors and factory methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Constructors and factory methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Constructors and factory methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Constructors and factory methods",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Constructors and factory methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Constructors and factory methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Constructors and factory methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Constructors and factory methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Constructors and factory methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Constructors and factory methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Constructors and factory methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Constructors and factory methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Constructors and factory methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Constructors and factory methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Constructors and factory methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Constructors and factory methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Constructors and factory methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Constructors and factory methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Constructors and factory methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Constructors and factory methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Constructors and factory methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Constructors and factory methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Constructors and factory methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Constructors and factory methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Constructors and factory methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Constructors and factory methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Constructors and factory methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Constructors and factory methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Constructors and factory methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Constructors and factory methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Constructors and factory methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Constructors and factory methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Constructors and factory methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Constructors and factory methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Constructors and factory methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Constructors and factory methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Constructors and factory methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Constructors and factory methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Constructors and factory methods",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-constructor-form",
    "category": "Client configuration",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Client configuration",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Client configuration",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Client configuration",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Client configuration",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Client configuration",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Client configuration",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Client configuration",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Client configuration",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Client configuration",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Client configuration",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Client configuration",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Client configuration",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Client configuration",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Client configuration",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Client configuration",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Client configuration",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Client configuration",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Client configuration",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Client configuration",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Client configuration",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Client configuration",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Client configuration",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Client configuration",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Client configuration",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Client configuration",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Client configuration",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Client configuration",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Client configuration",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Client configuration",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Client configuration",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Client configuration",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Client configuration",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Client configuration",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Client configuration",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Client configuration",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Client configuration",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Client configuration",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Client configuration",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Client configuration",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Client configuration",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Client configuration",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Client configuration",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Client configuration",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Client configuration",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Client configuration",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Client configuration",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Client configuration",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Client configuration",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Client configuration",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Client configuration",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Client configuration",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Client configuration",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Client configuration",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Client configuration",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Client configuration",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Client configuration",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Client configuration",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Client configuration",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Client configuration",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Client configuration",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Client configuration",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Client configuration",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Client configuration",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Client configuration",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Client configuration",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Client configuration",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Client configuration",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Client configuration",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Client configuration",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Client configuration",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Client configuration",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Client configuration",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Client configuration",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Client configuration",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Client configuration",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Client configuration",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Client configuration",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Client configuration",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Client configuration",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Client configuration",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Client configuration",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Client configuration",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Client configuration",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Client configuration",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Client configuration",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Client configuration",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Client configuration",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Client configuration",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Client configuration",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Client configuration",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Client configuration",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Client configuration",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Client configuration",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Client configuration",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Client configuration",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Client configuration",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Client configuration",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Client configuration",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Client configuration",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Client configuration",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Client configuration",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Client configuration",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Client configuration",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Client configuration",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Client configuration",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Client configuration",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Client configuration",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Client configuration",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Client configuration",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Client configuration",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Client configuration",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Client configuration",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Client configuration",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Client configuration",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Client configuration",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Client configuration",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Client configuration",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Client configuration",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Client configuration",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Client configuration",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Client configuration",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Client configuration",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Client configuration",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclass ExampleClientWithConnectionString:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "python\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Specifying the Service Version",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nfrom azure.identity import DefaultAzureCredential"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Specifying the Service Version",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Specifying the Service Version",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Specifying the Service Version",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Specifying the Service Version",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Specifying the Service Version",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Specifying the Service Version",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Specifying the Service Version",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Specifying the Service Version",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Specifying the Service Version",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Specifying the Service Version",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Specifying the Service Version",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Specifying the Service Version",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Specifying the Service Version",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Specifying the Service Version",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Specifying the Service Version",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Specifying the Service Version",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Specifying the Service Version",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Specifying the Service Version",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Specifying the Service Version",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Specifying the Service Version",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Specifying the Service Version",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Specifying the Service Version",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Specifying the Service Version",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Specifying the Service Version",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Specifying the Service Version",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Specifying the Service Version",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Specifying the Service Version",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Specifying the Service Version",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Specifying the Service Version",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Specifying the Service Version",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Specifying the Service Version",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Specifying the Service Version",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Specifying the Service Version",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Specifying the Service Version",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Specifying the Service Version",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Specifying the Service Version",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Specifying the Service Version",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Specifying the Service Version",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Specifying the Service Version",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Specifying the Service Version",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Specifying the Service Version",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Specifying the Service Version",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Specifying the Service Version",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Specifying the Service Version",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Specifying the Service Version",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Specifying the Service Version",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Specifying the Service Version",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Specifying the Service Version",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Specifying the Service Version",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Specifying the Service Version",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Specifying the Service Version",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Specifying the Service Version",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Specifying the Service Version",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Specifying the Service Version",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Specifying the Service Version",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Specifying the Service Version",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Specifying the Service Version",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Specifying the Service Version",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Specifying the Service Version",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Specifying the Service Version",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Specifying the Service Version",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Specifying the Service Version",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Specifying the Service Version",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Specifying the Service Version",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Specifying the Service Version",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Specifying the Service Version",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Specifying the Service Version",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Specifying the Service Version",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Specifying the Service Version",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Specifying the Service Version",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Specifying the Service Version",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Specifying the Service Version",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Specifying the Service Version",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Specifying the Service Version",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Specifying the Service Version",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Specifying the Service Version",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Specifying the Service Version",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Specifying the Service Version",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Specifying the Service Version",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Specifying the Service Version",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Specifying the Service Version",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Specifying the Service Version",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Specifying the Service Version",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Specifying the Service Version",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Specifying the Service Version",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Specifying the Service Version",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Specifying the Service Version",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Specifying the Service Version",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Specifying the Service Version",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Specifying the Service Version",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Specifying the Service Version",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Specifying the Service Version",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Specifying the Service Version",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Specifying the Service Version",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Specifying the Service Version",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Specifying the Service Version",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Specifying the Service Version",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Specifying the Service Version",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Specifying the Service Version",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Specifying the Service Version",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Specifying the Service Version",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Specifying the Service Version",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Specifying the Service Version",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Specifying the Service Version",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Specifying the Service Version",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Specifying the Service Version",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Specifying the Service Version",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Specifying the Service Version",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "latest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "By default, use the latest supported API version",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "By default, use the latest supported API version",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "By default, use the latest supported API version",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "By default, use the latest supported API version",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "By default, use the latest supported API version",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "By default, use the latest supported API version",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "By default, use the latest supported API version",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "By default, use the latest supported API version",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "By default, use the latest supported API version",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "By default, use the latest supported API version",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "By default, use the latest supported API version",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "By default, use the latest supported API version",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "By default, use the latest supported API version",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "By default, use the latest supported API version",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "By default, use the latest supported API version",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "By default, use the latest supported API version",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "By default, use the latest supported API version",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "By default, use the latest supported API version",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "By default, use the latest supported API version",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "By default, use the latest supported API version",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "By default, use the latest supported API version",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "By default, use the latest supported API version",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "By default, use the latest supported API version",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "By default, use the latest supported API version",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "By default, use the latest supported API version",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "By default, use the latest supported API version",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "By default, use the latest supported API version",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "By default, use the latest supported API version",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "By default, use the latest supported API version",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "By default, use the latest supported API version",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "By default, use the latest supported API version",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "By default, use the latest supported API version",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "By default, use the latest supported API version",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "By default, use the latest supported API version",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "By default, use the latest supported API version",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "By default, use the latest supported API version",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "By default, use the latest supported API version",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "By default, use the latest supported API version",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "By default, use the latest supported API version",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "By default, use the latest supported API version",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "By default, use the latest supported API version",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "By default, use the latest supported API version",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "By default, use the latest supported API version",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "By default, use the latest supported API version",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "By default, use the latest supported API version",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "By default, use the latest supported API version",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "By default, use the latest supported API version",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "By default, use the latest supported API version",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "By default, use the latest supported API version",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "By default, use the latest supported API version",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "By default, use the latest supported API version",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "By default, use the latest supported API version",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "By default, use the latest supported API version",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "By default, use the latest supported API version",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "By default, use the latest supported API version",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "By default, use the latest supported API version",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "By default, use the latest supported API version",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "By default, use the latest supported API version",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "By default, use the latest supported API version",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "By default, use the latest supported API version",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "By default, use the latest supported API version",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "By default, use the latest supported API version",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "By default, use the latest supported API version",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "By default, use the latest supported API version",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "By default, use the latest supported API version",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "By default, use the latest supported API version",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "By default, use the latest supported API version",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "By default, use the latest supported API version",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "By default, use the latest supported API version",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "By default, use the latest supported API version",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "By default, use the latest supported API version",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "specific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Additional constructor parameters",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Additional constructor parameters",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Additional constructor parameters",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Additional constructor parameters",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Additional constructor parameters",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Additional constructor parameters",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Additional constructor parameters",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Additional constructor parameters",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Additional constructor parameters",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Additional constructor parameters",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Additional constructor parameters",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Additional constructor parameters",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Additional constructor parameters",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Additional constructor parameters",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Additional constructor parameters",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Additional constructor parameters",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Additional constructor parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Additional constructor parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Additional constructor parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Additional constructor parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Additional constructor parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Additional constructor parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Additional constructor parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Additional constructor parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Additional constructor parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Additional constructor parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Additional constructor parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Additional constructor parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Additional constructor parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Additional constructor parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Additional constructor parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Additional constructor parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Additional constructor parameters",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Additional constructor parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Additional constructor parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Additional constructor parameters",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Additional constructor parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Additional constructor parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Additional constructor parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Additional constructor parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Additional constructor parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Additional constructor parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Additional constructor parameters",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Additional constructor parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Additional constructor parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Additional constructor parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Additional constructor parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Additional constructor parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Additional constructor parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Additional constructor parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Additional constructor parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Additional constructor parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Additional constructor parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Additional constructor parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Additional constructor parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Additional constructor parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Additional constructor parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Additional constructor parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Additional constructor parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Additional constructor parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Additional constructor parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Additional constructor parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Additional constructor parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Additional constructor parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Additional constructor parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Additional constructor parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Additional constructor parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Additional constructor parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Additional constructor parameters",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Additional constructor parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Additional constructor parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Additional constructor parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Additional constructor parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Additional constructor parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Additional constructor parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Additional constructor parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Additional constructor parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Additional constructor parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Additional constructor parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Additional constructor parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Additional constructor parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Additional constructor parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Additional constructor parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Additional constructor parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Additional constructor parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Additional constructor parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Additional constructor parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Additional constructor parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Additional constructor parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Additional constructor parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Additional constructor parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Additional constructor parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Additional constructor parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Additional constructor parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Additional constructor parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Additional constructor parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Additional constructor parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Additional constructor parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Additional constructor parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Additional constructor parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Additional constructor parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Additional constructor parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Additional constructor parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Additional constructor parameters",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Client immutability",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Client immutability",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Client immutability",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Client immutability",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Client immutability",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Client immutability",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Client immutability",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Client immutability",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Client immutability",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Client immutability",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Client immutability",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Client immutability",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Client immutability",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Client immutability",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Client immutability",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Client immutability",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Client immutability",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Client immutability",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Client immutability",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Client immutability",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Client immutability",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Client immutability",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Client immutability",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Client immutability",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Client immutability",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Client immutability",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Client immutability",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Client immutability",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Client immutability",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Client immutability",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Client immutability",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Client immutability",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Client immutability",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Client immutability",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Client immutability",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Client immutability",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Client immutability",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Client immutability",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Client immutability",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Client immutability",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Client immutability",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Client immutability",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Client immutability",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Client immutability",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Client immutability",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Client immutability",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Client immutability",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Client immutability",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Client immutability",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Client immutability",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Client immutability",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Client immutability",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Client immutability",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Client immutability",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Client immutability",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Client immutability",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Client immutability",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Client immutability",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Client immutability",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Client immutability",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Client immutability",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Client immutability",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Client immutability",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Client immutability",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Client immutability",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Client immutability",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Client immutability",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Client immutability",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Client immutability",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Client immutability",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Client immutability",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Client immutability",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Client immutability",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Client immutability",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Client immutability",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Client immutability",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Client immutability",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Client immutability",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Client immutability",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Client immutability",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Client immutability",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Client immutability",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Client immutability",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Client immutability",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Client immutability",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Client immutability",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Client immutability",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Client immutability",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Client immutability",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Client immutability",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Client immutability",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Client immutability",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Client immutability",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Client immutability",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Client immutability",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Client immutability",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Client immutability",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Client immutability",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Client immutability",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Client immutability",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Client immutability",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Client immutability",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Client immutability",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Client immutability",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Client immutability",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Client immutability",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Client immutability",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Client immutability",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Client immutability",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Client immutability",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Client immutability",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Client immutability",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Client immutability",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-verbs",
    "category": "Service methods",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Service methods",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Service methods",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Service methods",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Service methods",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Service methods",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Service methods",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Service methods",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Service methods",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service methods",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service methods",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service methods",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service methods",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service methods",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service methods",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service methods",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service methods",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service methods",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service methods",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service methods",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service methods",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service methods",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service methods",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service methods",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service methods",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service methods",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service methods",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service methods",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service methods",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service methods",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Service methods",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-verbs",
    "category": "Naming",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Naming",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Naming",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Naming",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Naming",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Naming",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Naming",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Naming",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Naming",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Naming",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Naming",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Naming",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Naming",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Naming",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Naming",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Naming",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Naming",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Naming",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Naming",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Naming",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Naming",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Naming",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Naming",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Naming",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Naming",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Naming",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Naming",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Naming",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Naming",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Naming",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Naming",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Naming",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Naming",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Naming",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Naming",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Naming",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Naming",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Naming",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Naming",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Naming",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Naming",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Naming",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Naming",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Naming",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Naming",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Naming",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Naming",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Naming",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Naming",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Naming",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Naming",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Naming",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Naming",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Naming",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Naming",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Naming",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Naming",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Naming",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Naming",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Naming",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Naming",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Naming",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Naming",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Naming",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Naming",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Naming",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Naming",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Naming",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Naming",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Naming",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Naming",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Naming",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Naming",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Naming",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Naming",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Naming",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Naming",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Naming",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Naming",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Naming",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Naming",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Naming",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Naming",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Naming",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Naming",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Naming",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Naming",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Naming",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Naming",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Naming",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Naming",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Naming",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Naming",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Naming",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Naming",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Naming",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Naming",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Naming",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Naming",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Naming",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Naming",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Naming",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Naming",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Naming",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Naming",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Naming",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Naming",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Naming",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Naming",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Naming",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Naming",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Naming",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Naming",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Requests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "The logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Return types",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Return types",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclient = ComputeClient(...)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Do not return None or a boolean to indicate errors:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Return types",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Return types",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Return types",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Return types",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Return types",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Return types",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Return types",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Return types",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Return types",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Return types",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Return types",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Return types",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Return types",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Return types",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Return types",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Return types",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Return types",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Return types",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Return types",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Return types",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Return types",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Return types",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Return types",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Return types",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Return types",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Return types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Return types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Return types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Return types",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Return types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Return types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Return types",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Return types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Return types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Return types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Return types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Return types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Return types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Return types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Return types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Return types",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Return types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Return types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Return types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Return types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Return types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Return types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Return types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Return types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Return types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Return types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Return types",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Return types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Return types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Return types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Return types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Return types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Return types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Return types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Return types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Return types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Return types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Return types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Return types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Return types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Return types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Return types",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Return types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Return types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Return types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Return types",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Return types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Return types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Return types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Return types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Return types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Return types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Return types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Return types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Return types",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Return types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Return types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Return types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Return types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Return types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Return types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Return types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Return types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Return types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Return types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Return types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Return types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Return types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Return types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Return types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Return types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Return types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Return types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Return types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Return types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Return types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Return types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Return types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Return types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Return types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Return types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Return types",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Yes",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "resource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\"."
  },
  {
    "id": null,
    "category": "No",
    "text": "Consider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "No",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "No",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "No",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Cancellation",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Cancellation",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Cancellation",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Cancellation",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Cancellation",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Cancellation",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Cancellation",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Cancellation",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Cancellation",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Cancellation",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Cancellation",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Cancellation",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Cancellation",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Cancellation",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Cancellation",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Cancellation",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Cancellation",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Cancellation",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Cancellation",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Cancellation",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Cancellation",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Cancellation",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Cancellation",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Cancellation",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Cancellation",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Cancellation",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Cancellation",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Cancellation",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Cancellation",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Cancellation",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Cancellation",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Cancellation",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Cancellation",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Cancellation",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Cancellation",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Cancellation",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Cancellation",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Cancellation",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Cancellation",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Cancellation",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Cancellation",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Cancellation",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Cancellation",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Cancellation",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Cancellation",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Cancellation",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Cancellation",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Cancellation",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Cancellation",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Cancellation",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Cancellation",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Cancellation",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Cancellation",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Cancellation",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Cancellation",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Cancellation",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Cancellation",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Cancellation",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Cancellation",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Cancellation",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Cancellation",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Cancellation",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Cancellation",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Cancellation",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Cancellation",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Cancellation",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Cancellation",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Cancellation",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Cancellation",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Cancellation",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Cancellation",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Cancellation",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Cancellation",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Cancellation",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Cancellation",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Cancellation",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Cancellation",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Cancellation",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Cancellation",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Cancellation",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Cancellation",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Cancellation",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Cancellation",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Cancellation",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Cancellation",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Cancellation",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Cancellation",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Cancellation",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Cancellation",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Cancellation",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Cancellation",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Cancellation",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Cancellation",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Cancellation",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Cancellation",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Cancellation",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Cancellation",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Cancellation",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Cancellation",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Cancellation",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Cancellation",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Cancellation",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Cancellation",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Cancellation",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Cancellation",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service Method Parameters",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service Method Parameters",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service Method Parameters",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service Method Parameters",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service Method Parameters",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service Method Parameters",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service Method Parameters",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service Method Parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service Method Parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service Method Parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service Method Parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service Method Parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service Method Parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service Method Parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service Method Parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service Method Parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service Method Parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service Method Parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service Method Parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service Method Parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service Method Parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service Method Parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service Method Parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service Method Parameters",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service Method Parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service Method Parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service Method Parameters",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service Method Parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service Method Parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service Method Parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service Method Parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service Method Parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service Method Parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service Method Parameters",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service Method Parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service Method Parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service Method Parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service Method Parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service Method Parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service Method Parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service Method Parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service Method Parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service Method Parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service Method Parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service Method Parameters",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service Method Parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service Method Parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service Method Parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service Method Parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service Method Parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service Method Parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service Method Parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service Method Parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service Method Parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service Method Parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service Method Parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service Method Parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service Method Parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service Method Parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service Method Parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service Method Parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service Method Parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service Method Parameters",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service Method Parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service Method Parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service Method Parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service Method Parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service Method Parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service Method Parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service Method Parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service Method Parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service Method Parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service Method Parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service Method Parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service Method Parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service Method Parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service Method Parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service Method Parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service Method Parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service Method Parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service Method Parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service Method Parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service Method Parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service Method Parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service Method Parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service Method Parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service Method Parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service Method Parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service Method Parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service Method Parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service Method Parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service Method Parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service Method Parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service Method Parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service Method Parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service Method Parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service Method Parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Service Method Parameters",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "client.do_stuff(timeout=32)\n```"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "The service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Parameter validation",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Parameter validation",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Parameter validation",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Parameter validation",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Parameter validation",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Parameter validation",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Parameter validation",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Parameter validation",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Parameter validation",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Parameter validation",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Parameter validation",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Parameter validation",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Parameter validation",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Parameter validation",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Parameter validation",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Parameter validation",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Parameter validation",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Parameter validation",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Parameter validation",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Parameter validation",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Parameter validation",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Parameter validation",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Parameter validation",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Parameter validation",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Parameter validation",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Parameter validation",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Parameter validation",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Parameter validation",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Parameter validation",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Parameter validation",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Parameter validation",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Parameter validation",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Parameter validation",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Parameter validation",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Parameter validation",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Parameter validation",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Parameter validation",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Parameter validation",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Parameter validation",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Parameter validation",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Parameter validation",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Parameter validation",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Parameter validation",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Parameter validation",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Parameter validation",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Parameter validation",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Parameter validation",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Parameter validation",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Parameter validation",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Parameter validation",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Parameter validation",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Parameter validation",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Parameter validation",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Parameter validation",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Parameter validation",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Parameter validation",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Parameter validation",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Parameter validation",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Parameter validation",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Parameter validation",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Parameter validation",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Parameter validation",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Parameter validation",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Parameter validation",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Parameter validation",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Parameter validation",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Parameter validation",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Parameter validation",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Parameter validation",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Parameter validation",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Parameter validation",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Parameter validation",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Parameter validation",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Parameter validation",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Parameter validation",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Parameter validation",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Parameter validation",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Parameter validation",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Parameter validation",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Parameter validation",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Parameter validation",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Parameter validation",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Parameter validation",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Parameter validation",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Parameter validation",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Parameter validation",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Parameter validation",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Parameter validation",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Parameter validation",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Parameter validation",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Parameter validation",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Parameter validation",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Parameter validation",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Parameter validation",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Parameter validation",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Parameter validation",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Parameter validation",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Parameter validation",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Parameter validation",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Parameter validation",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No:",
    "text": "def get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No:",
    "text": "try:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')"
  },
  {
    "id": null,
    "category": "No:",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "No:",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No:",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No:",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No:",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No:",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "No:",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "No:",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "No:",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "No:",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No:",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "No:",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "No:",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No:",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No:",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No:",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No:",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No:",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No:",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No:",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No:",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No:",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No:",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No:",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No:",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No:",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No:",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No:",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No:",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No:",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No:",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No:",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No:",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No:",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No:",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No:",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No:",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No:",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No:",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No:",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No:",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No:",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No:",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No:",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No:",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No:",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "try:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes:",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes:",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes:",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes:",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes:",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes:",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes:",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-client-service-args",
    "category": "Common service operation parameters",
    "text": "DO support the common arguments for service operations:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Common service operation parameters",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Common service operation parameters",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Common service operation parameters",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Common service operation parameters",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Common service operation parameters",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Common service operation parameters",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Common service operation parameters",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Common service operation parameters",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Common service operation parameters",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Common service operation parameters",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Common service operation parameters",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Common service operation parameters",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Common service operation parameters",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Common service operation parameters",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Common service operation parameters",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Common service operation parameters",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Common service operation parameters",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Common service operation parameters",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Common service operation parameters",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Common service operation parameters",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Common service operation parameters",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Common service operation parameters",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Common service operation parameters",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Common service operation parameters",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Common service operation parameters",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Common service operation parameters",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Common service operation parameters",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Common service operation parameters",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Common service operation parameters",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Common service operation parameters",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Common service operation parameters",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Common service operation parameters",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Common service operation parameters",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Common service operation parameters",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Common service operation parameters",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Common service operation parameters",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Common service operation parameters",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Common service operation parameters",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Common service operation parameters",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Common service operation parameters",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Common service operation parameters",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Common service operation parameters",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Common service operation parameters",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Common service operation parameters",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Common service operation parameters",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Common service operation parameters",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Common service operation parameters",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Common service operation parameters",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Common service operation parameters",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Common service operation parameters",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Common service operation parameters",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Common service operation parameters",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Common service operation parameters",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Common service operation parameters",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Common service operation parameters",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Common service operation parameters",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Common service operation parameters",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Common service operation parameters",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Common service operation parameters",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Common service operation parameters",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Common service operation parameters",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Common service operation parameters",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Common service operation parameters",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Common service operation parameters",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Common service operation parameters",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Common service operation parameters",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Common service operation parameters",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Common service operation parameters",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Common service operation parameters",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Common service operation parameters",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Common service operation parameters",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Common service operation parameters",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Common service operation parameters",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Common service operation parameters",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Common service operation parameters",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Common service operation parameters",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Common service operation parameters",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Common service operation parameters",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Common service operation parameters",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Common service operation parameters",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Common service operation parameters",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Common service operation parameters",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Common service operation parameters",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Common service operation parameters",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Common service operation parameters",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Common service operation parameters",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Common service operation parameters",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Common service operation parameters",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Common service operation parameters",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Common service operation parameters",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Common service operation parameters",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def do_something(thing: \"Thing\"):\n    ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "do_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class Client:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "thing = Thing(name='hello', size=4711, description='This is a description...')"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes:",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes:",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes:",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "client.update_thing(name='hello', size=4713, thing=thing)\n```"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Services may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "In Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Methods returning collections (paging)",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Methods returning collections (paging)",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Methods returning collections (paging)",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Methods returning collections (paging)",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Methods returning collections (paging)",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Methods returning collections (paging)",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Methods returning collections (paging)",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Methods returning collections (paging)",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Methods returning collections (paging)",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Methods returning collections (paging)",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Methods returning collections (paging)",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Methods returning collections (paging)",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Methods returning collections (paging)",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Methods returning collections (paging)",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Methods returning collections (paging)",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Methods returning collections (paging)",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Methods returning collections (paging)",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Methods returning collections (paging)",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Methods returning collections (paging)",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Methods returning collections (paging)",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Methods returning collections (paging)",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Methods returning collections (paging)",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Methods returning collections (paging)",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Methods returning collections (paging)",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Methods returning collections (paging)",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Methods returning collections (paging)",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Methods returning collections (paging)",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Methods returning collections (paging)",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Methods returning collections (paging)",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Methods returning collections (paging)",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Methods returning collections (paging)",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Methods returning collections (paging)",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Methods returning collections (paging)",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Methods returning collections (paging)",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Methods returning collections (paging)",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Methods returning collections (paging)",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Methods returning collections (paging)",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Methods returning collections (paging)",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Methods returning collections (paging)",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Methods returning collections (paging)",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Methods returning collections (paging)",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Methods returning collections (paging)",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Methods returning collections (paging)",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Methods returning collections (paging)",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Methods returning collections (paging)",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Methods returning collections (paging)",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Methods returning collections (paging)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Methods returning collections (paging)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Methods returning collections (paging)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Methods returning collections (paging)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Methods returning collections (paging)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Methods returning collections (paging)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Methods returning collections (paging)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Methods returning collections (paging)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Methods returning collections (paging)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Methods returning collections (paging)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Methods returning collections (paging)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Methods returning collections (paging)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Methods returning collections (paging)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Methods returning collections (paging)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Methods returning collections (paging)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Methods returning collections (paging)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Methods returning collections (paging)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Methods returning collections (paging)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Methods returning collections (paging)",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "List all things - paging happens transparently in the",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "List all things - paging happens transparently in the",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "List all things - paging happens transparently in the",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "List all things - paging happens transparently in the",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "List all things - paging happens transparently in the",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "List all things - paging happens transparently in the",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "List all things - paging happens transparently in the",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "List all things - paging happens transparently in the",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "List all things - paging happens transparently in the",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "List all things - paging happens transparently in the",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "List all things - paging happens transparently in the",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "List all things - paging happens transparently in the",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "List all things - paging happens transparently in the",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "List all things - paging happens transparently in the",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "List all things - paging happens transparently in the",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "List all things - paging happens transparently in the",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "List all things - paging happens transparently in the",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "List all things - paging happens transparently in the",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "List all things - paging happens transparently in the",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "List all things - paging happens transparently in the",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "List all things - paging happens transparently in the",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "List all things - paging happens transparently in the",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "List all things - paging happens transparently in the",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "List all things - paging happens transparently in the",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "List all things - paging happens transparently in the",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "List all things - paging happens transparently in the",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "List all things - paging happens transparently in the",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "List all things - paging happens transparently in the",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "List all things - paging happens transparently in the",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "background.",
    "text": "for thing in client.list_things():\n    print(thing)"
  },
  {
    "id": null,
    "category": "background.",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "background.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "background.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "background.",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "background.",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "background.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "background.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "background.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "background.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "background.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "background.",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "background.",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "background.",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "background.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "background.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "background.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "background.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "background.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "background.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "background.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "background.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "background.",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "background.",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "background.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "background.",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "background.",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "background.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "background.",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "background.",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "background.",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "background.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "background.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "background.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "background.",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "background.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "background.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "background.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "background.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "background.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "background.",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "background.",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "background.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "background.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "background.",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "background.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "background.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "background.",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "background.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "background.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "background.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "background.",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "background.",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "background.",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "background.",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "background.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "background.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "background.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "background.",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "background.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "background.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "background.",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "background.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "background.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "background.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "background.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "background.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "background.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "background.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "background.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "background.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "background.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "background.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "background.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "background.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "background.",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "background.",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "background.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "background.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "background.",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "background.",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "background.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "background.",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "background.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "background.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "background.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "background.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "background.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "background.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "background.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "background.",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "background.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "background.",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "background.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "background.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "background.",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "background.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "background.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "background.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "background.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "background.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "background.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "background.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "background.",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "background.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "background.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "background.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "background.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "background.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "background.",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "background.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "background.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "background.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "background.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "background.",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "background.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "background.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "background.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "background.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "background.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "background.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "background.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "background.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "background.",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "background.",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "for page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python\nclient = ExampleClient(...)"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "The protocol also allows you to list things by page...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "The protocol also allows you to list things by page...",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "for thing in client.list_things(continuation_token='...'):\n    print(thing)"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "for page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Service operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Python client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Methods invoking long running operations",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Methods invoking long running operations",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Methods invoking long running operations",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Methods invoking long running operations",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Methods invoking long running operations",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Methods invoking long running operations",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Methods invoking long running operations",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Methods invoking long running operations",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Methods invoking long running operations",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Methods invoking long running operations",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Methods invoking long running operations",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Methods invoking long running operations",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Methods invoking long running operations",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Methods invoking long running operations",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Methods invoking long running operations",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Methods invoking long running operations",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Methods invoking long running operations",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Methods invoking long running operations",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Methods invoking long running operations",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Methods invoking long running operations",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Methods invoking long running operations",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Methods invoking long running operations",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Methods invoking long running operations",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Methods invoking long running operations",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Methods invoking long running operations",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Methods invoking long running operations",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Methods invoking long running operations",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Methods invoking long running operations",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Methods invoking long running operations",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Methods invoking long running operations",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Methods invoking long running operations",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Methods invoking long running operations",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Methods invoking long running operations",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Methods invoking long running operations",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Methods invoking long running operations",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Methods invoking long running operations",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Methods invoking long running operations",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Methods invoking long running operations",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Methods invoking long running operations",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Methods invoking long running operations",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Methods invoking long running operations",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Methods invoking long running operations",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Methods invoking long running operations",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Methods invoking long running operations",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Methods invoking long running operations",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Methods invoking long running operations",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Methods invoking long running operations",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Methods invoking long running operations",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Methods invoking long running operations",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Methods invoking long running operations",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Methods invoking long running operations",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Methods invoking long running operations",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Methods invoking long running operations",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Methods invoking long running operations",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Methods invoking long running operations",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Methods invoking long running operations",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Methods invoking long running operations",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Methods invoking long running operations",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Methods invoking long running operations",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Methods invoking long running operations",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Methods invoking long running operations",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Methods invoking long running operations",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Methods invoking long running operations",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Methods invoking long running operations",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Methods invoking long running operations",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Methods invoking long running operations",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Methods invoking long running operations",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Methods invoking long running operations",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Methods invoking long running operations",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Methods invoking long running operations",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Methods invoking long running operations",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Methods invoking long running operations",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Methods invoking long running operations",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Methods invoking long running operations",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Methods invoking long running operations",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Methods invoking long running operations",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Methods invoking long running operations",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Methods invoking long running operations",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Methods invoking long running operations",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Methods invoking long running operations",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Methods invoking long running operations",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-method-conditional-request",
    "category": "Conditional request methods",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Conditional request methods",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python\nclass Thing:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "thing = client.get_thing('theName')"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Conditional request methods",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Conditional request methods",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Conditional request methods",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Conditional request methods",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Conditional request methods",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Conditional request methods",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Conditional request methods",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Conditional request methods",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Conditional request methods",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Conditional request methods",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Conditional request methods",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Conditional request methods",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Conditional request methods",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Conditional request methods",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Conditional request methods",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Conditional request methods",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Conditional request methods",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Conditional request methods",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Conditional request methods",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Conditional request methods",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Conditional request methods",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Conditional request methods",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Conditional request methods",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Conditional request methods",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Conditional request methods",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Conditional request methods",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Conditional request methods",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Conditional request methods",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Conditional request methods",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Conditional request methods",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Conditional request methods",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Conditional request methods",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Conditional request methods",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Conditional request methods",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Conditional request methods",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Conditional request methods",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Conditional request methods",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Conditional request methods",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Conditional request methods",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Conditional request methods",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Conditional request methods",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Conditional request methods",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Conditional request methods",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Conditional request methods",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Conditional request methods",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Conditional request methods",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Conditional request methods",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Conditional request methods",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Conditional request methods",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Conditional request methods",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Conditional request methods",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Conditional request methods",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Conditional request methods",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Conditional request methods",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Conditional request methods",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Conditional request methods",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Conditional request methods",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Conditional request methods",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Conditional request methods",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Conditional request methods",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Conditional request methods",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Conditional request methods",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Conditional request methods",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Conditional request methods",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Conditional request methods",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Conditional request methods",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Conditional request methods",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Conditional request methods",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Conditional request methods",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Conditional request methods",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Conditional request methods",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Conditional request methods",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Conditional request methods",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Conditional request methods",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Conditional request methods",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Conditional request methods",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Conditional request methods",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Conditional request methods",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Conditional request methods",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Conditional request methods",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Conditional request methods",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Conditional request methods",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Conditional request methods",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Conditional request methods",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Conditional request methods",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Conditional request methods",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "client.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "client.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Uses the explicitly provided etag.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Uses the explicitly provided etag.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Uses the explicitly provided etag.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Uses the explicitly provided etag.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Uses the explicitly provided etag.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Uses the explicitly provided etag.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Uses the explicitly provided etag.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Uses the explicitly provided etag.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Uses the explicitly provided etag.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Uses the explicitly provided etag.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Uses the explicitly provided etag.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Uses the explicitly provided etag.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Uses the explicitly provided etag.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Uses the explicitly provided etag.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Uses the explicitly provided etag.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Uses the explicitly provided etag.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Uses the explicitly provided etag.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Uses the explicitly provided etag.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Uses the explicitly provided etag.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Uses the explicitly provided etag.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Uses the explicitly provided etag.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Uses the explicitly provided etag.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Uses the explicitly provided etag.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Uses the explicitly provided etag.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Uses the explicitly provided etag.",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Many services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Hierarchical clients",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Hierarchical clients",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Hierarchical clients",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Hierarchical clients",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Hierarchical clients",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Hierarchical clients",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Hierarchical clients",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Hierarchical clients",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Hierarchical clients",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Hierarchical clients",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Hierarchical clients",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Hierarchical clients",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Hierarchical clients",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Hierarchical clients",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Hierarchical clients",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Hierarchical clients",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Hierarchical clients",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Hierarchical clients",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Hierarchical clients",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Hierarchical clients",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Hierarchical clients",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Hierarchical clients",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Hierarchical clients",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Hierarchical clients",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Hierarchical clients",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Hierarchical clients",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Hierarchical clients",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Hierarchical clients",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Hierarchical clients",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Hierarchical clients",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Hierarchical clients",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Hierarchical clients",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Hierarchical clients",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Hierarchical clients",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Hierarchical clients",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Hierarchical clients",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Hierarchical clients",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Hierarchical clients",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Hierarchical clients",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Hierarchical clients",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Hierarchical clients",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Hierarchical clients",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Hierarchical clients",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Hierarchical clients",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Hierarchical clients",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Hierarchical clients",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Hierarchical clients",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Hierarchical clients",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Hierarchical clients",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Hierarchical clients",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Hierarchical clients",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Hierarchical clients",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Hierarchical clients",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Hierarchical clients",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Hierarchical clients",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Hierarchical clients",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Hierarchical clients",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Hierarchical clients",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Hierarchical clients",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Hierarchical clients",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Hierarchical clients",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Hierarchical clients",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Hierarchical clients",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Hierarchical clients",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Hierarchical clients",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Hierarchical clients",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Hierarchical clients",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Hierarchical clients",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Hierarchical clients",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Hierarchical clients",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Hierarchical clients",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Hierarchical clients",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Hierarchical clients",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Hierarchical clients",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Hierarchical clients",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Hierarchical clients",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Hierarchical clients",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Hierarchical clients",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Hierarchical clients",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Hierarchical clients",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Hierarchical clients",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Hierarchical clients",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supporting types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supporting types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supporting types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supporting types",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supporting types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supporting types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supporting types",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supporting types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supporting types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supporting types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supporting types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supporting types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supporting types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supporting types",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supporting types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supporting types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supporting types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supporting types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supporting types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supporting types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supporting types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supporting types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supporting types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supporting types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supporting types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supporting types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supporting types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supporting types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supporting types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supporting types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supporting types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supporting types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supporting types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supporting types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supporting types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supporting types",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supporting types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supporting types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supporting types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supporting types",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supporting types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supporting types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supporting types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supporting types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supporting types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supporting types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supporting types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supporting types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supporting types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supporting types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supporting types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supporting types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supporting types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supporting types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supporting types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supporting types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supporting types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supporting types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supporting types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supporting types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supporting types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supporting types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supporting types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supporting types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supporting types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supporting types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supporting types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supporting types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supporting types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supporting types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supporting types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supporting types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Supporting types",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Client libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Data within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Model types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Model types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Model types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Model types",
    "text": "DO NOT duplicate models between the root and aio namespace."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "In order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Model types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "The following table enumerates the various models you might create:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Model types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Model types",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Model types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Model types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Model types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Model types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Model types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Model types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Model types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Model types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Model types",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Model types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Model types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Model types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Model types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Model types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Model types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Model types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Model types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Model types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Model types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Model types",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Model types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Model types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Model types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Model types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Model types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Model types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Model types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Model types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Model types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Model types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Model types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Model types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Model types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Model types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Model types",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Model types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Model types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Model types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Model types",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Model types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Model types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Model types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Model types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Model types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Model types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Model types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Model types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Model types",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Model types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Model types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Model types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Model types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Model types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Model types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Model types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Model types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Model types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Model types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Model types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Model types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Model types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Model types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Model types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Model types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Model types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Model types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Model types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Model types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Model types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Model types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Model types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Model types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Model types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Model types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Model types",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```"
  },
  {
    "id": "python-models-enum-string",
    "category": "An example of a model type.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "An example of a model type.",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "An example of a model type.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "An example of a model type.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "An example of a model type.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "An example of a model type.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "An example of a model type.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "An example of a model type.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "An example of a model type.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "An example of a model type.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "An example of a model type.",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "An example of a model type.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "An example of a model type.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "An example of a model type.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "An example of a model type.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "An example of a model type.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "An example of a model type.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "An example of a model type.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "An example of a model type.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "An example of a model type.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "An example of a model type.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```python"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "An example of a model type.",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "An example of a model type.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "An example of a model type.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "An example of a model type.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "An example of a model type.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "An example of a model type.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "An example of a model type.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "An example of a model type.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "An example of a model type.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "An example of a model type.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "An example of a model type.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "An example of a model type.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "An example of a model type.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "An example of a model type.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "An example of a model type.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "An example of a model type.",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "An example of a model type.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "An example of a model type.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "An example of a model type.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "An example of a model type.",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "An example of a model type.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "An example of a model type.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "An example of a model type.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "An example of a model type.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "An example of a model type.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "An example of a model type.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "An example of a model type.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "An example of a model type.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "An example of a model type.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "An example of a model type.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "An example of a model type.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "An example of a model type.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "An example of a model type.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "An example of a model type.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "An example of a model type.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "An example of a model type.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "An example of a model type.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "An example of a model type.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "An example of a model type.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "An example of a model type.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "An example of a model type.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "An example of a model type.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "An example of a model type.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "An example of a model type.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "An example of a model type.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "An example of a model type.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "An example of a model type.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "An example of a model type.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "An example of a model type.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "An example of a model type.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "An example of a model type.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "An example of a model type.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "An example of a model type.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "An example of a model type.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "An example of a model type.",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-models-enum-string",
    "category": "Enumerations",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Enumerations",
    "text": "DO use UPPERCASE names for enum names."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Enumerations",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Enumerations",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Enumerations",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Enumerations",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Enumerations",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Enumerations",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Enumerations",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Enumerations",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Enumerations",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Enumerations",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Enumerations",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Enumerations",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Enumerations",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Enumerations",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Enumerations",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Enumerations",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Enumerations",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Enumerations",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Enumerations",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Enumerations",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Enumerations",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Enumerations",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Enumerations",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Enumerations",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Enumerations",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Enumerations",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Enumerations",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Enumerations",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Enumerations",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Enumerations",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Enumerations",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Enumerations",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Enumerations",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Enumerations",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Enumerations",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Enumerations",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Enumerations",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Enumerations",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Enumerations",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Enumerations",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Enumerations",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Enumerations",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Enumerations",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Enumerations",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Enumerations",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Enumerations",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Enumerations",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Enumerations",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Enumerations",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Enumerations",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Enumerations",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Enumerations",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Enumerations",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Enumerations",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Enumerations",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Enumerations",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Enumerations",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Enumerations",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Enumerations",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Enumerations",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Enumerations",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Enumerations",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Enumerations",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Enumerations",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Enumerations",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Enumerations",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Enumerations",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Enumerations",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Enumerations",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Enumerations",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Enumerations",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Enumerations",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Enumerations",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Enumerations",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "class MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "No",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "No",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "No",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "No",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Exceptions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "For higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Exceptions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Exceptions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Exceptions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Exceptions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Exceptions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Exceptions",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Exceptions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Exceptions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Exceptions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Exceptions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Exceptions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Exceptions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Exceptions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Exceptions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Exceptions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Exceptions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Exceptions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Exceptions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Exceptions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Exceptions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Exceptions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Exceptions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Exceptions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Exceptions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Exceptions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Exceptions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Exceptions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Exceptions",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Exceptions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Exceptions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Exceptions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Exceptions",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Exceptions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Exceptions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Exceptions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Exceptions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Exceptions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Exceptions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Exceptions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Exceptions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Exceptions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Exceptions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Exceptions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Exceptions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Exceptions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Exceptions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Exceptions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Exceptions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Exceptions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Exceptions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Exceptions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Exceptions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Exceptions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Exceptions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Exceptions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Exceptions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Exceptions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Exceptions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Exceptions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Exceptions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Exceptions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Exceptions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Exceptions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Exceptions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Exceptions",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Authentication",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Authentication",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Authentication",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Authentication",
    "text": "DO support all authentication methods that the service supports."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Authentication",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Authentication",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Authentication",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Authentication",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Authentication",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Authentication",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Authentication",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Authentication",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Authentication",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Authentication",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Authentication",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Authentication",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Authentication",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Authentication",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Authentication",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Authentication",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Authentication",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Authentication",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Authentication",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Authentication",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Authentication",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Authentication",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Authentication",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Authentication",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Authentication",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Authentication",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Authentication",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Authentication",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Authentication",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Authentication",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Authentication",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Authentication",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Authentication",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Authentication",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Authentication",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Authentication",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Authentication",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Authentication",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Authentication",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Authentication",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Authentication",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Authentication",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Authentication",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Authentication",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Authentication",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Authentication",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Authentication",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Authentication",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Authentication",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Authentication",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Authentication",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Authentication",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Authentication",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Authentication",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Authentication",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Authentication",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Authentication",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Authentication",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Authentication",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Authentication",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Authentication",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "In the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Namespaces",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Namespaces",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "A compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Namespaces",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Namespaces",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "If you want to use a group name segment, use one of the following groups:"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Namespaces",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Namespaces",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Namespaces",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Namespaces",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Namespaces",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Namespaces",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Namespaces",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Namespaces",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Namespaces",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Namespaces",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Namespaces",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Namespaces",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Namespaces",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Namespaces",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Namespaces",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Namespaces",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Namespaces",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Namespaces",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Namespaces",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Namespaces",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Namespaces",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Namespaces",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Namespaces",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Namespaces",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Namespaces",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Namespaces",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Namespaces",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Namespaces",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Namespaces",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Namespaces",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Namespaces",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Namespaces",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Namespaces",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Namespaces",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Namespaces",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Namespaces",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Namespaces",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Namespaces",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Namespaces",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Namespaces",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Namespaces",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Namespaces",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Namespaces",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Namespaces",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Namespaces",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Namespaces",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Namespaces",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Namespaces",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Namespaces",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Namespaces",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Namespaces",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Namespaces",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Namespaces",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Namespaces",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Namespaces",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice.aio import ExampleServiceClient"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes:",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "from azure.exampleservice import AsyncExampleServiceClient\n```"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "```python"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No: Wrong namespace, wrong client name...",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Here are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Example Namespaces",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Example Namespaces",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Example Namespaces",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Example Namespaces",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Example Namespaces",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Example Namespaces",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Example Namespaces",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Example Namespaces",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Example Namespaces",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Example Namespaces",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Example Namespaces",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Example Namespaces",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Example Namespaces",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Example Namespaces",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Example Namespaces",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Example Namespaces",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Example Namespaces",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Example Namespaces",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Example Namespaces",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Example Namespaces",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Example Namespaces",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Example Namespaces",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Example Namespaces",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Example Namespaces",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Example Namespaces",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Example Namespaces",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Example Namespaces",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Example Namespaces",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Example Namespaces",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Example Namespaces",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Example Namespaces",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Example Namespaces",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Example Namespaces",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Example Namespaces",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Example Namespaces",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Example Namespaces",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Example Namespaces",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Example Namespaces",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Example Namespaces",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Example Namespaces",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Example Namespaces",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Example Namespaces",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Example Namespaces",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Example Namespaces",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Example Namespaces",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Example Namespaces",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Example Namespaces",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Example Namespaces",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Example Namespaces",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Example Namespaces",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Example Namespaces",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Example Namespaces",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Example Namespaces",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Example Namespaces",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Example Namespaces",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Example Namespaces",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Example Namespaces",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Example Namespaces",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "The asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Async support",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Async support",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Async support",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "```python"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Async support",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Async support",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Async support",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Async support",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Async support",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Async support",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Async support",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Async support",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Async support",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Async support",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Async support",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Async support",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Async support",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Async support",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Async support",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Async support",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Async support",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Async support",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Async support",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Async support",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Async support",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Async support",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Async support",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Async support",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Async support",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Async support",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Async support",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Async support",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Async support",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Async support",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Async support",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Async support",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Async support",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Async support",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Async support",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Async support",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Async support",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Async support",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Async support",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Async support",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Async support",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Async support",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Async support",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Async support",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Async support",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Async support",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Async support",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Async support",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Async support",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Async support",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Async support",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Async support",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Async support",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Async support",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Yes",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "class ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example.aio",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example.aio",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example.aio",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example.aio",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example.aio",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example.aio",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example.aio",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example.aio",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example.aio",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example.aio",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example.aio",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example.aio",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example.aio",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example.aio",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example.aio",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example.aio",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example.aio",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example.aio",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example.aio",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example.aio",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example.aio",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example.aio",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example.aio",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example.aio",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example.aio",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example.aio",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example.aio",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example.aio",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example.aio",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example.aio",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example.aio",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example.aio",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example.aio",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example.aio",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example.aio",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example.aio",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example.aio",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example.aio",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example.aio",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example.aio",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example.aio",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example.aio",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example.aio",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example.aio",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example.aio",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example.aio",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example.aio",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example.aio",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example.aio",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example.aio",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example.aio",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example.aio",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example.aio",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example.aio",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "In module azure.example.aio",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient:\n    def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "No",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "No",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "No",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "No",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "No",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "No",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "No",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "No",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "No",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "No",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "No",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "No",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "No",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "No",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "No",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "No",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "No",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "class ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "```python\nfrom azure.storage.blob import BlobServiceClient # Sync client"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "from azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "In module azure.example",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK distribution packages",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK distribution packages",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK distribution packages",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK distribution packages",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK distribution packages",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK distribution packages",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK distribution packages",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK distribution packages",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK distribution packages",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK distribution packages",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK distribution packages",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK distribution packages",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK distribution packages",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK distribution packages",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK distribution packages",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK distribution packages",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK distribution packages",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK distribution packages",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK distribution packages",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK distribution packages",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK distribution packages",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK distribution packages",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK distribution packages",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK distribution packages",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Azure SDK distribution packages",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Packaging",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Packaging",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Packaging",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Packaging",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Packaging",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Packaging",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Packaging",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Packaging",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Packaging",
    "text": "DO include __init__.py for the namespace(s) in sdists"
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Packaging",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Packaging",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Packaging",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Packaging",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Packaging",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Packaging",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Packaging",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Packaging",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Packaging",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Packaging",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Packaging",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Packaging",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Packaging",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Packaging",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Packaging",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Packaging",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Packaging",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Packaging",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Packaging",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Packaging",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Packaging",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Packaging",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Packaging",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Packaging",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Packaging",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Packaging",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Packaging",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Packaging",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Packaging",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Packaging",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Packaging",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Packaging",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Packaging",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Packaging",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Packaging",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Packaging",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Packaging",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Packaging",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Packaging",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service-specific common library code",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service-specific common library code",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "A common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries"
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Let's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service-specific common library code",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service-specific common library code",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service-specific common library code",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service-specific common library code",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service-specific common library code",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service-specific common library code",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service-specific common library code",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service-specific common library code",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service-specific common library code",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service-specific common library code",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service-specific common library code",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service-specific common library code",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service-specific common library code",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service-specific common library code",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service-specific common library code",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service-specific common library code",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service-specific common library code",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service-specific common library code",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service-specific common library code",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service-specific common library code",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service-specific common library code",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service-specific common library code",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service-specific common library code",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service-specific common library code",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service-specific common library code",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service-specific common library code",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service-specific common library code",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service-specific common library code",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service-specific common library code",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service-specific common library code",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service-specific common library code",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service-specific common library code",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service-specific common library code",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service-specific common library code",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service-specific common library code",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service-specific common library code",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Service-specific common library code",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-versioning-semver",
    "category": "Package Versioning",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Package Versioning",
    "text": "DO use the bN pre-release segment for beta releases."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Don't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Package Versioning",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Package Versioning",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Package Versioning",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Package Versioning",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Package Versioning",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Package Versioning",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Package Versioning",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "The bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Package Versioning",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Package Versioning",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Package Versioning",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Package Versioning",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Package Versioning",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Package Versioning",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Package Versioning",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Package Versioning",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Package Versioning",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Package Versioning",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Package Versioning",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Package Versioning",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Package Versioning",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Package Versioning",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Package Versioning",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Package Versioning",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Package Versioning",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Package Versioning",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Package Versioning",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Package Versioning",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Package Versioning",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Package Versioning",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Package Versioning",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Package Versioning",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Package Versioning",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Package Versioning",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Dependencies",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:"
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Dependencies",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Dependencies",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board]."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "When you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Dependencies",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "Only applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Dependencies",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Dependencies",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Dependencies",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Dependencies",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Dependencies",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Dependencies",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Dependencies",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Dependencies",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Dependencies",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Dependencies",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Dependencies",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Dependencies",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Dependencies",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Dependencies",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Dependencies",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Dependencies",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Dependencies",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Dependencies",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Dependencies",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Dependencies",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Dependencies",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Dependencies",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-native-approval",
    "category": "Binary extensions (native code)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Binary extensions (native code)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Binary extensions (native code)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Binary extensions (native code)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Binary extensions (native code)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Binary extensions (native code)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Binary extensions (native code)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Binary extensions (native code)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Binary extensions (native code)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Binary extensions (native code)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Binary extensions (native code)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Binary extensions (native code)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Binary extensions (native code)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Binary extensions (native code)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Binary extensions (native code)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Binary extensions (native code)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Binary extensions (native code)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Binary extensions (native code)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Binary extensions (native code)",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Docstrings",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Docstrings",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Docstrings",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "Example:\n```python\ndef request(method, url, headers, **kwargs): ..."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "def get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Docstrings",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Docstrings",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Docstrings",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Docstrings",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Docstrings",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Docstrings",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Docstrings",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Docstrings",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Docstrings",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Docstrings",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Docstrings",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Docstrings",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Docstrings",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Docstrings",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Docstrings",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Docstrings",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-snippets-include",
    "category": "Code snippets",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Code snippets",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Code snippets",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "Use the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Code snippets",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Code snippets",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Code snippets",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Code snippets",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Code snippets",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Code snippets",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Code snippets",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Code snippets",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Code snippets",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Code snippets",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Code snippets",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Code snippets",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Code snippets",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Code snippets",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Repository Guidelines",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Repository Guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Repository Guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Repository Guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Repository Guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Repository Guidelines",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Repository Guidelines",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Repository Guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Repository Guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Repository Guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Repository Guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Repository Guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Repository Guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Repository Guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Repository Guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Repository Guidelines",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Repository Guidelines",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Documentation style",
    "text": "There are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Documentation style",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Documentation style",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Documentation style",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Documentation style",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors."
  },
  {
    "id": null,
    "category": "Documentation style",
    "text": "As you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": null,
    "category": "Documentation style",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Documentation style",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Documentation style",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Documentation style",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Documentation style",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Documentation style",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Documentation style",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Documentation style",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Documentation style",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Documentation style",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Documentation style",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": null,
    "category": "Samples",
    "text": "Code samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Samples",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Samples",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Samples",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Samples",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Samples",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Samples",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Samples",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Samples",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation."
  },
  {
    "id": null,
    "category": "Samples",
    "text": "Combined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project."
  },
  {
    "id": null,
    "category": "Samples",
    "text": "{% include refs.md %}\n{% include_relative refs.md %}"
  }
]