[
  {
    "id": "python-feature-support",
    "category": "Introduction",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Introduction",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Introduction",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Introduction",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Introduction",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Introduction",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Introduction",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Introduction",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Introduction",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Introduction",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Introduction",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Introduction",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Introduction",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Introduction",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Introduction",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Introduction",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Introduction",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Introduction",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Introduction",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Introduction",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Introduction",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Introduction",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Introduction",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Introduction",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Introduction",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Introduction",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Introduction",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Introduction",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Introduction",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Introduction",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Introduction",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Introduction",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Introduction",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Introduction",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Introduction",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Introduction",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Introduction",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Introduction",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Introduction",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Introduction",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Introduction",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Introduction",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Introduction",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Introduction",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Introduction",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Introduction",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Introduction",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Introduction",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Introduction",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Introduction",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Introduction",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Introduction",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Introduction",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Introduction",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Introduction",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Introduction",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Introduction",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Introduction",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Introduction",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Introduction",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Introduction",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Introduction",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Introduction",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Introduction",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Introduction",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Introduction",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Introduction",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Introduction",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Introduction",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Introduction",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Introduction",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Introduction",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Introduction",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Introduction",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Introduction",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Introduction",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Introduction",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Introduction",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Introduction",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Introduction",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Introduction",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Introduction",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Introduction",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Introduction",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Introduction",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Introduction",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Introduction",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Introduction",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Introduction",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Introduction",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Introduction",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Introduction",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Introduction",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Introduction",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Introduction",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Introduction",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Introduction",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Introduction",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Introduction",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Introduction",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Introduction",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Introduction",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Introduction",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Introduction",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Introduction",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Introduction",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Introduction",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Introduction",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Introduction",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Introduction",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Introduction",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Introduction",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Introduction",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Introduction",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Introduction",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Introduction",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Introduction",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Introduction",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Introduction",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Introduction",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Introduction",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Introduction",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Introduction",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Introduction",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Introduction",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Introduction",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Introduction",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Introduction",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Introduction",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe Azure SDK should be designed to enhance the productivity of developers connecting to Azure services. Other qualities (such as completeness, extensibility, and performance) are important but secondary. Productivity is achieved by adhering to the principles described below:\nThe SDK should follow the design guidelines and conventions for the target language. It should feel natural to a developer in the target language.\nWe embrace the ecosystem with its strengths and its flaws.\nWe work with the ecosystem to improve it for all developers.\nClient libraries should be consistent within the language, consistent with the service and consistent between all target languages. In cases of conflict, consistency within the language is the highest priority and consistency between all target languages is the lowest priority.\nService-agnostic concepts such as logging, HTTP communication, and error handling should be consistent. The developer should not have to relearn service-agnostic concepts as they move between client libraries.\nConsistency of terminology between the client library and the service is a good thing that aids in diagnosability.\nAll differences between the service and client library must have a good (articulated) reason for existing, rooted in idiomatic usage rather than whim.\nThe Azure SDK for each target language feels like a single product developed by a single team.\nThere should be feature parity across target languages. This is more important than feature parity with the service.\nWe are experts in the supported technologies so our customers, the developers, don't have to be.\nDevelopers should find great documentation (hero tutorial, how to articles, samples, and API documentation) that makes it easy to be successful with the Azure service.\nGetting off the ground should be easy through the use of predictable defaults that implement best practices. Think about progressive concept disclosure.\nThe SDK should be easily acquired through the most normal mechanisms in the target language and ecosystem.\nDevelopers can be overwhelmed when learning new service concepts. The core use cases should be discoverable.\nThe developer should be able to understand what is going on.\nIt should be discoverable when and under what circumstances a network call is made.\nDefaults are discoverable and their intent is clear.\nLogging, tracing, and exception handling are fundamental and should be thoughtful.\nError messages should be concise, correlated with the service, actionable, and human readable. Ideally, the error message should lead the consumer to a useful action that they can take.\nIntegrating with the preferred debugger for the target language should be easy.\nBreaking changes are more harmful to a user's experience than most new features and improvements are beneficial.\nIncompatibilities should never be introduced deliberately without thorough review and very strong justification.\nDo not rely on dependencies that can force our hand on compatibility.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "Design principles",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Design principles",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Design principles",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Design principles",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Design principles",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Design principles",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Design principles",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Design principles",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Design principles",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Design principles",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Design principles",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Design principles",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Design principles",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Design principles",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Design principles",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Design principles",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Design principles",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Design principles",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Design principles",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Design principles",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Design principles",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Design principles",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Design principles",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Design principles",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Design principles",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Design principles",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Design principles",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Design principles",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Design principles",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Design principles",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Design principles",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Design principles",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Design principles",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Design principles",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Design principles",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Design principles",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Design principles",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Design principles",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Design principles",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Design principles",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Design principles",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Design principles",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Design principles",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Design principles",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Design principles",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Design principles",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Design principles",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Design principles",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Design principles",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Design principles",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Design principles",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Design principles",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Design principles",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Design principles",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Design principles",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Design principles",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Design principles",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Design principles",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Design principles",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Design principles",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Design principles",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Design principles",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Design principles",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Design principles",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Design principles",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Design principles",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Design principles",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Design principles",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Design principles",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Design principles",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Design principles",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Design principles",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Design principles",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Design principles",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Design principles",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Design principles",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Design principles",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Design principles",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Design principles",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Design principles",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Design principles",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Design principles",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Design principles",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Design principles",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Design principles",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Design principles",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Design principles",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Design principles",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Design principles",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Design principles",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Design principles",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Design principles",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Design principles",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Design principles",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Design principles",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Design principles",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Design principles",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Design principles",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Design principles",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Design principles",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Design principles",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Design principles",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Design principles",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Design principles",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Design principles",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Design principles",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Design principles",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Design principles",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Design principles",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Design principles",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Design principles",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Design principles",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Design principles",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Design principles",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Design principles",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Design principles",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Design principles",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Design principles",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Design principles",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Design principles",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Design principles",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Design principles",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Design principles",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Design principles",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Design principles",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Design principles",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Design principles",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Design principles",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Design principles",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "python-feature-support",
    "category": "General guidelines",
    "text": "DO support 100% of the features provided by the Azure service the client library represents. Gaps in functionality cause confusion and frustration among developers.\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "General guidelines",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "General guidelines",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "General guidelines",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "General guidelines",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "General guidelines",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "General guidelines",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "General guidelines",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "General guidelines",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "General guidelines",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "General guidelines",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "General guidelines",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "General guidelines",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "General guidelines",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "General guidelines",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "General guidelines",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "General guidelines",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "General guidelines",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "General guidelines",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "General guidelines",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "General guidelines",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "General guidelines",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "General guidelines",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "General guidelines",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "General guidelines",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "General guidelines",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "General guidelines",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "General guidelines",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "General guidelines",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "General guidelines",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "General guidelines",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "General guidelines",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "General guidelines",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "General guidelines",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "General guidelines",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "General guidelines",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "General guidelines",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "General guidelines",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "General guidelines",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "General guidelines",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "General guidelines",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "General guidelines",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "General guidelines",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "General guidelines",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "General guidelines",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "General guidelines",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "General guidelines",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "General guidelines",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "General guidelines",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "General guidelines",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "General guidelines",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "General guidelines",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "General guidelines",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "General guidelines",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "General guidelines",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "General guidelines",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "General guidelines",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "General guidelines",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "General guidelines",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "General guidelines",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "General guidelines",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "General guidelines",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "General guidelines",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "General guidelines",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "General guidelines",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "General guidelines",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "General guidelines",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "General guidelines",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "General guidelines",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "General guidelines",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "General guidelines",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "General guidelines",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "General guidelines",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "General guidelines",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "General guidelines",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "General guidelines",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "General guidelines",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "General guidelines",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "General guidelines",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "General guidelines",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "General guidelines",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "General guidelines",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "General guidelines",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "General guidelines",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "General guidelines",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "General guidelines",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "General guidelines",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "General guidelines",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "General guidelines",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "General guidelines",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "General guidelines",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "General guidelines",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "General guidelines",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "General guidelines",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "General guidelines",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "General guidelines",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "General guidelines",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "General guidelines",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "General guidelines",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "General guidelines",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "General guidelines",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "General guidelines",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "General guidelines",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "General guidelines",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "General guidelines",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "General guidelines",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "General guidelines",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "General guidelines",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "General guidelines",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "General guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "General guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "General guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "General guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "General guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "General guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "General guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "General guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "General guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "General guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "General guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "General guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThese guidelines were written primarily with a HTTP based request/response in mind, but many general guidelines apply to other types of services as well. This includes, but is not limited to, packaging and naming, tools and project structures.\n\nPlease contact the [Architecture board] for more guidance on non HTTP/REST based services."
  },
  {
    "id": "python-general-version-support",
    "category": "Non-HTTP based services",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Non-HTTP based services",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Non-HTTP based services",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Non-HTTP based services",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Non-HTTP based services",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Non-HTTP based services",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Non-HTTP based services",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Non-HTTP based services",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Non-HTTP based services",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Non-HTTP based services",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Non-HTTP based services",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Non-HTTP based services",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Non-HTTP based services",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Non-HTTP based services",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Non-HTTP based services",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Non-HTTP based services",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Non-HTTP based services",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Non-HTTP based services",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Non-HTTP based services",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Non-HTTP based services",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Non-HTTP based services",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Non-HTTP based services",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Non-HTTP based services",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Non-HTTP based services",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Non-HTTP based services",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Non-HTTP based services",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Non-HTTP based services",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Non-HTTP based services",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Non-HTTP based services",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Non-HTTP based services",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Non-HTTP based services",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Non-HTTP based services",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Non-HTTP based services",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Non-HTTP based services",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Non-HTTP based services",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Non-HTTP based services",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Non-HTTP based services",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Non-HTTP based services",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Non-HTTP based services",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Non-HTTP based services",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Non-HTTP based services",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Non-HTTP based services",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Non-HTTP based services",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Non-HTTP based services",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Non-HTTP based services",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Non-HTTP based services",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Non-HTTP based services",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Non-HTTP based services",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Non-HTTP based services",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Non-HTTP based services",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Non-HTTP based services",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Non-HTTP based services",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Non-HTTP based services",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Non-HTTP based services",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Non-HTTP based services",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Non-HTTP based services",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Non-HTTP based services",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Non-HTTP based services",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Non-HTTP based services",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Non-HTTP based services",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Non-HTTP based services",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Non-HTTP based services",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Non-HTTP based services",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Non-HTTP based services",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Non-HTTP based services",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Non-HTTP based services",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Non-HTTP based services",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Non-HTTP based services",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Non-HTTP based services",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Non-HTTP based services",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Non-HTTP based services",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Non-HTTP based services",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Non-HTTP based services",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Non-HTTP based services",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Non-HTTP based services",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Non-HTTP based services",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Non-HTTP based services",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Non-HTTP based services",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Non-HTTP based services",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Non-HTTP based services",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Non-HTTP based services",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Non-HTTP based services",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Non-HTTP based services",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Non-HTTP based services",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Non-HTTP based services",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Non-HTTP based services",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Non-HTTP based services",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Non-HTTP based services",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Non-HTTP based services",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Non-HTTP based services",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Non-HTTP based services",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Non-HTTP based services",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Non-HTTP based services",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Non-HTTP based services",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Non-HTTP based services",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Non-HTTP based services",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Non-HTTP based services",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Non-HTTP based services",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Non-HTTP based services",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Non-HTTP based services",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Non-HTTP based services",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Non-HTTP based services",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Non-HTTP based services",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Non-HTTP based services",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Non-HTTP based services",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Non-HTTP based services",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Non-HTTP based services",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Non-HTTP based services",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-general-version-support",
    "category": "Supported python versions",
    "text": "DO support Python 3.7+.\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Supported python versions",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Supported python versions",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Supported python versions",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Supported python versions",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Supported python versions",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Supported python versions",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Supported python versions",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Supported python versions",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Supported python versions",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Supported python versions",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Supported python versions",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Supported python versions",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Supported python versions",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Supported python versions",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Supported python versions",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Supported python versions",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Supported python versions",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Supported python versions",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Supported python versions",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Supported python versions",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Supported python versions",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Supported python versions",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Supported python versions",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Supported python versions",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Supported python versions",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Supported python versions",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Supported python versions",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Supported python versions",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Supported python versions",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Supported python versions",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Supported python versions",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Supported python versions",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Supported python versions",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Supported python versions",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Supported python versions",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Supported python versions",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Supported python versions",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Supported python versions",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Supported python versions",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Supported python versions",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Supported python versions",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Supported python versions",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Supported python versions",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supported python versions",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supported python versions",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supported python versions",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supported python versions",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supported python versions",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supported python versions",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supported python versions",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supported python versions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supported python versions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supported python versions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supported python versions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supported python versions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supported python versions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supported python versions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supported python versions",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supported python versions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supported python versions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supported python versions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supported python versions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supported python versions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supported python versions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supported python versions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supported python versions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supported python versions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supported python versions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supported python versions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supported python versions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supported python versions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supported python versions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supported python versions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supported python versions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supported python versions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supported python versions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supported python versions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supported python versions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supported python versions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supported python versions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supported python versions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supported python versions",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supported python versions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supported python versions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supported python versions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supported python versions",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supported python versions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supported python versions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supported python versions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supported python versions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supported python versions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supported python versions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supported python versions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supported python versions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supported python versions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supported python versions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supported python versions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supported python versions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supported python versions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supported python versions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supported python versions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supported python versions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supported python versions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supported python versions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supported python versions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supported python versions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supported python versions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supported python versions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supported python versions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supported python versions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supported python versions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supported python versions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supported python versions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supported python versions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supported python versions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supported python versions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supported python versions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supported python versions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supported python versions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nYour API surface will consist of one or more service clients that the consumer will instantiate to connect to your service, plus a set of supporting types.\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Azure SDK API Design",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Azure SDK API Design",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Azure SDK API Design",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Azure SDK API Design",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Azure SDK API Design",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Azure SDK API Design",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Azure SDK API Design",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Azure SDK API Design",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Azure SDK API Design",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Azure SDK API Design",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Azure SDK API Design",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Azure SDK API Design",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Azure SDK API Design",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Azure SDK API Design",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Azure SDK API Design",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Azure SDK API Design",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Azure SDK API Design",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Azure SDK API Design",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Azure SDK API Design",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Azure SDK API Design",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Azure SDK API Design",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Azure SDK API Design",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Azure SDK API Design",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Azure SDK API Design",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Azure SDK API Design",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Azure SDK API Design",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Azure SDK API Design",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Azure SDK API Design",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Azure SDK API Design",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Azure SDK API Design",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Azure SDK API Design",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Azure SDK API Design",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Azure SDK API Design",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Azure SDK API Design",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Azure SDK API Design",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Azure SDK API Design",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Azure SDK API Design",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Azure SDK API Design",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Azure SDK API Design",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Azure SDK API Design",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Azure SDK API Design",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Azure SDK API Design",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Azure SDK API Design",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Azure SDK API Design",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Azure SDK API Design",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Azure SDK API Design",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Azure SDK API Design",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Azure SDK API Design",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Azure SDK API Design",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Azure SDK API Design",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Azure SDK API Design",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Azure SDK API Design",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Azure SDK API Design",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Azure SDK API Design",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Azure SDK API Design",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Azure SDK API Design",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Azure SDK API Design",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Azure SDK API Design",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Azure SDK API Design",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Azure SDK API Design",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Azure SDK API Design",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Azure SDK API Design",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK API Design",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK API Design",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK API Design",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK API Design",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK API Design",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK API Design",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK API Design",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK API Design",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK API Design",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK API Design",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK API Design",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK API Design",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK API Design",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK API Design",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK API Design",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK API Design",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK API Design",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK API Design",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK API Design",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK API Design",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK API Design",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK API Design",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK API Design",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK API Design",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK API Design",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK API Design",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK API Design",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK API Design",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK API Design",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK API Design",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK API Design",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK API Design",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK API Design",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK API Design",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK API Design",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK API Design",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK API Design",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK API Design",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK API Design",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK API Design",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK API Design",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK API Design",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK API Design",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK API Design",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK API Design",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe service client is the primary entry point for users of the library. A service client exposes one or more methods that allow them to interact with the service."
  },
  {
    "id": "python-client-namespace",
    "category": "Service client",
    "text": "DO expose the service clients the user is more likely to interact with from the root namespace of your package. Specialized service clients may be placed in sub-namespaces."
  },
  {
    "id": "python-client-naming",
    "category": "Service client",
    "text": "DO name service client types with a Client suffix."
  },
  {
    "id": "python-client-sync-async-separate-clients",
    "category": "Service client",
    "text": "DO provide separate sync and async clients. See the Async Support section for more information.\n\n```python\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Service client",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Service client",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Service client",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Service client",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Service client",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Service client",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Service client",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Service client",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Service client",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Service client",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Service client",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Service client",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Service client",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Service client",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Service client",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Service client",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Service client",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Service client",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Service client",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Service client",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Service client",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Service client",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Service client",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Service client",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Service client",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Service client",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Service client",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Service client",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Service client",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Service client",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Service client",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Service client",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Service client",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Service client",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Service client",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Service client",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Service client",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Service client",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Service client",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Service client",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Service client",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Service client",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Service client",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Service client",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Service client",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Service client",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Service client",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Service client",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Service client",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Service client",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Service client",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Service client",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Service client",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Service client",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Service client",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Service client",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Service client",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Service client",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Service client",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Service client",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Service client",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Service client",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Service client",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Service client",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Service client",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Service client",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Service client",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Service client",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Service client",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Service client",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Service client",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Service client",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Service client",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Service client",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Service client",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Service client",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Service client",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Service client",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Service client",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Service client",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Service client",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Service client",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Service client",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Service client",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Service client",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Service client",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Service client",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Service client",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Service client",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Service client",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Service client",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Service client",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Service client",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Service client",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Service client",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Service client",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Service client",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Service client",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Service client",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Service client",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Service client",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Service client",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Service client",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Service client",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Service client",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Service client",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Service client",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Service client",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Service client",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Service client",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Service client",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Service client",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Service client",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Service client",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Service client",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Service client",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Service client",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Service client",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Service client",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Service client",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Service client",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass CosmosClient: ...\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "Yes",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "Yes",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "Yes",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "Yes",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Yes",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Yes",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Yes",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Yes",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Yes",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Yes",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Yes",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Yes",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Yes",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Yes",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Yes",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Yes",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Yes",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Yes",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Yes",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Yes",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass CosmosProxy: ...\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "No",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "No",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "No",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "No",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "No",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "No",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "No",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "No",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "No",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "No",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "No",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "No",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "No",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "No",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "No",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "No",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "No",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "No",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "No",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass CosmosUrl: ...\n```"
  },
  {
    "id": "python-client-immutable",
    "category": "No",
    "text": "DO make the service client immutable. See the Client Immutability section for more information.\n\nOnly the minimal information needed to connect and interact with the service should be required in order to construct a client instance. All additional information should be optional and passed in as optional keyword-only arguments."
  },
  {
    "id": "python-client-constructor-form",
    "category": "No",
    "text": "DO provide a constructor that takes positional binding parameters (for example, the name of, or a URL pointing to the service instance), a positional credential parameter, a transport keyword-only parameter, and keyword-only arguments for passing settings through to individual HTTP pipeline policies. See the Authentication section for more information on the credential parameter."
  },
  {
    "id": "python-client-options-naming",
    "category": "No",
    "text": "DO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments."
  },
  {
    "id": "python-client-constructor-policy-arguments",
    "category": "No",
    "text": "DO accept optional default request options as keyword arguments and pass them along to its pipeline policies. See Common service operation parameters for more information.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "No",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "No",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "No",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "No",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "No",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "No",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "No",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "No",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "No",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "No",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "No",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "No",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "No",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "No",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "No",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient = ExampleClient('https://contoso.com/xmpl',\n                       DefaultAzureCredential(),\n                       max_retries=18,\n                       timeout=2)\n```"
  },
  {
    "id": "python-client-constructor-transport-argument",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO allow users to pass in a transport keyword-only argument that allows the caller to specify a specific transport instance. The default value should be the RequestsTransport for synchronous clients and the AioHttpTransport for async clients."
  },
  {
    "id": "python-client-connection-string",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\n\nThe method should parse the connection string and pass the values along with any additional keyword-only arguments except credential to the constructor.  Only provide a from_connection_string factory method if the Azure portal exposes a connection string for your service.\n\n```python\nclass ExampleClientWithConnectionString:\n\n```\n\npython\n{% include_relative _includes/example_client.py %}"
  },
  {
    "id": "python-client-constructor-from-url",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY use a separate factory classmethod from_<resource type>_url (e.g. from_blob_url) to create a client from a URL (if the service relies on passing URLs to resources around - e.g. Azure Blob Storage). The from_url factory method should take the same set of optional keyword arguments as the constructor."
  },
  {
    "id": "python-client-constructor-api-version-argument-1",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO accept an optional api_version keyword-only argument of type string. If specified, the provided api version MUST be used when interacting with the service. If the parameter is not provided, the default value MUST be the latest non-preview API version understood by the client library (if there the service has a non-preview version) or the latest preview API version understood by the client library (if the service does not have any non-preview API versions yet). This parameter MUST be available even if there is only one API version understood by the service in order to allow library developers to lock down the API version they expect to interact with the service with.\n\n```python\nfrom azure.identity import DefaultAzureCredential\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Change default number of retries to 18 and overall timeout to 2s.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nlatest_known_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential())\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "By default, use the latest supported API version",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "By default, use the latest supported API version",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "By default, use the latest supported API version",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "By default, use the latest supported API version",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "By default, use the latest supported API version",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "By default, use the latest supported API version",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "By default, use the latest supported API version",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "By default, use the latest supported API version",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "By default, use the latest supported API version",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "By default, use the latest supported API version",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "By default, use the latest supported API version",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "By default, use the latest supported API version",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "By default, use the latest supported API version",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "By default, use the latest supported API version",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "By default, use the latest supported API version",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "By default, use the latest supported API version",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "By default, use the latest supported API version",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "By default, use the latest supported API version",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "By default, use the latest supported API version",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "By default, use the latest supported API version",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "By default, use the latest supported API version",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "By default, use the latest supported API version",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "By default, use the latest supported API version",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "By default, use the latest supported API version",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "By default, use the latest supported API version",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "By default, use the latest supported API version",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "By default, use the latest supported API version",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "By default, use the latest supported API version",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "By default, use the latest supported API version",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "By default, use the latest supported API version",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "By default, use the latest supported API version",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "By default, use the latest supported API version",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "By default, use the latest supported API version",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "By default, use the latest supported API version",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "By default, use the latest supported API version",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "By default, use the latest supported API version",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "By default, use the latest supported API version",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "By default, use the latest supported API version",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "By default, use the latest supported API version",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "By default, use the latest supported API version",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "By default, use the latest supported API version",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "By default, use the latest supported API version",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "By default, use the latest supported API version",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "By default, use the latest supported API version",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "By default, use the latest supported API version",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "By default, use the latest supported API version",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "By default, use the latest supported API version",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "By default, use the latest supported API version",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "By default, use the latest supported API version",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "By default, use the latest supported API version",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "By default, use the latest supported API version",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "By default, use the latest supported API version",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "By default, use the latest supported API version",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "By default, use the latest supported API version",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "By default, use the latest supported API version",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "By default, use the latest supported API version",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "By default, use the latest supported API version",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "By default, use the latest supported API version",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "By default, use the latest supported API version",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "By default, use the latest supported API version",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "By default, use the latest supported API version",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "By default, use the latest supported API version",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "By default, use the latest supported API version",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "By default, use the latest supported API version",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "By default, use the latest supported API version",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "By default, use the latest supported API version",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "By default, use the latest supported API version",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "By default, use the latest supported API version",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "By default, use the latest supported API version",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "By default, use the latest supported API version",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "By default, use the latest supported API version",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "By default, use the latest supported API version",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "By default, use the latest supported API version",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "By default, use the latest supported API version",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "By default, use the latest supported API version",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "By default, use the latest supported API version",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "By default, use the latest supported API version",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "By default, use the latest supported API version",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "By default, use the latest supported API version",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "By default, use the latest supported API version",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nspecific_api_version_client = ExampleClient('https://contoso.com/xmpl',\n                                            DefaultAzureCredential(),\n                                            api_version='1971-11-01')\n```"
  },
  {
    "id": "python-client-constructor-api-version-argument-2",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document the service API version that is used by default."
  },
  {
    "id": "python-client-constructor-api-version-argument-3",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document in which API version a feature (function or parameter) was introduced in if not all service API versions support it."
  },
  {
    "id": "python-client-constructor-api-version-argument-4",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY validate the input api_version value against a list of supported API versions."
  },
  {
    "id": "python-client-constructor-api-version-argument-5",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY include all service API versions that are supported by the client library in a ServiceVersion enumerated value.\n\n|Name|Description|\n|-|-|\n|credential|Credentials to use when making service requests (See Authentication)|\n|application_id|Name of the client application making the request. Used for telemetry|\n|api_version|API version to use when making service requests (See Service Version) |\n|transport|Override the default HTTP transport (See Client Configuration)|"
  },
  {
    "id": "python-client-immutable-design",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO design the client to be immutable. This does not mean that you need to use read-only properties (attributes are still acceptable), but rather that the there should not be any scenarios that require callers to change properties/attributes of the client."
  },
  {
    "id": "python-client-service-verbs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|"
  },
  {
    "id": "python-client-standardize-verbs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO standardize verb prefixes outside the list of preferred verbs for a given service across language SDKs. If a verb is called download in one language, we should avoid naming it fetch in another."
  },
  {
    "id": "python-lro-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO prefix methods with begin_ for long running operations."
  },
  {
    "id": "python-paged-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO prefix methods with list_ for methods that enumerate (lists) resources\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body, and the status line. For example, you may wish to expose an ETag header as an etag attribute on the logical entity. For more information see Model Types."
  },
  {
    "id": "python-response-logical-entity",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "python-response-exception-on-failure",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO raise an exception if the method call failed to accomplish the user specified task. This includes both situations where the service actively responded with a failure as well as when no response was received. See Exceptions for more information.\n\n```python\nclient = ComputeClient(...)\n\ntry:\n    # Please note that there is no status code etc. as part of the response.\n    # If the call fails, you will get an exception that will include the status code\n    # (if the request was made)\n    virtual_machine  = client.get_virtual_machine('example')\n    print(f'Virtual machine instance looks like this: {virtual_machine}')\nexcept azure.core.exceptions.ServiceRequestError as e:\n    print(f'Failed to make the request - feel free to retry. But the specifics are here: {e}')\nexcept azure.core.exceptions.ServiceResponseError as e:\n    print(f'The request was made, but the service responded with an error. Status code: {e.status_code}')\n```\n\nDo not return None or a boolean to indicate errors:\n\n```python\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "...but allow the caller to specify a specific API version as welll",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\ntry:\n    resource = client.create_resource(name)\nexcept azure.core.errors.ResourceExistsException:\n    print('Failed - we need to fix this!')\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "Yes",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nresource = client.create_resource(name):\nif not resource:\n    print('Failed - we need to fix this!')\n```"
  },
  {
    "id": "python-errors-normal-responses",
    "category": "No",
    "text": "DO NOT throw an exception for \"normal responses\".\n\nConsider an exists method. The method must distinguish between the service returned a client error 404/NotFound and a failure to even make a request:\n\n```python\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\ntry:\n    exists = client.resource_exists(name):\n    if not exists:\n        print(\"The resource doesn't exist...\")\nexcept azure.core.errors.ServiceRequestError:\n    print(\"We don't know if the resource exists - so it was appropriate to throw an exception!\")\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "Yes",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "Yes",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "Yes",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "Yes",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "Yes",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Yes",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\ntry:\n    client.resource_exists(name)\nexcept azure.core.errors.ResourceNotFoundException:\n    print(\"The resource doesn't exist... but that shouldn't be an exceptional case for an 'exists' method\")\n```"
  },
  {
    "id": "python-client-cancellation-sync-methods",
    "category": "No",
    "text": "DO provide an optional keyword argument timeout to allow callers to specify how long they are willing to wait for the method to complete. The timeout is in seconds, and should be honored to the best extent possible."
  },
  {
    "id": "python-client-cancellation-async-methods",
    "category": "No",
    "text": "DO use the standard asyncio.Task.cancel method to cancel async methods."
  },
  {
    "id": "python-client-optional-arguments-keyword-only",
    "category": "No",
    "text": "DO provide optional operation-specific arguments as keyword only. See [positional and keyword-only arguments] for more information."
  },
  {
    "id": "python-client-service-per-call-args",
    "category": "No",
    "text": "DO provide keyword-only arguments that override per-request policy options. The name of the parameters MUST mirror the name of the arguments provided in the client constructor or factory methods.\nFor a full list of supported optional arguments used for pipeline policy and transport configuration (both at the client constructor and per service operation), see the Azure Core developer documentation."
  },
  {
    "id": "python-client-service-args-conflict",
    "category": "No",
    "text": "DO qualify a service parameter name if it conflicts with any of the documented pipeline policy or transport configuration options used with all service operations and client constructors.\n\n```python\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "No",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient = ExampleClient('https://contoso.com/xmpl', DefaultAzureCredential(), max_retries=18, timeout=2)\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Set the default number of retries to 18 and timeout to 2s for this client instance.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient.do_stuff(timeout=32)\n```\n\nThe service client will have several methods that send requests to the service. Service parameters are directly passed across the wire to an Azure service. Client parameters aren't passed directly to the service, but used within the client library to fulfill the request. Parameters that are used to construct a URI, or a file to be uploaded are examples of client parameters."
  },
  {
    "id": "python-params-client-validation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO validate client parameters. Validation is especially important for parameters used to build up the URL since a malformed URL means that the client library will end up calling an incorrect endpoint.\n\n```python\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Override the client default timeout for this specific call to 32s (but max_retries is kept to 18)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\ndef get_thing(name: str) -> str:\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('') # Ooops - we will end up calling '/things/' which usually lists 'things'. We wanted a specific 'thing'.\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "No:",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "No:",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "No:",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "No:",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "No:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "No:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "No:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "No:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No:",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No:",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No:",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No:",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No:",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No:",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\ndef get_thing(name: str) -> str:\n    if not name:\n        raise ValueError('name must be a non-empty string')\n    url = f'https:///things/{name}'\n    return requests.get(url).json()\n\ntry:\n    thing = get_thing('')\nexcept ValueError:\n    print('We called with some invalid parameters. We should fix that.')\n```"
  },
  {
    "id": "python-params-service-validation",
    "category": "Yes:",
    "text": "DO NOT validate service parameters. Don't do null checks, empty string checks, or other common validating conditions on service parameters. Let the service validate all request parameters."
  },
  {
    "id": "python-params-devex",
    "category": "Yes:",
    "text": "DO verify that the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. Work with the service team if the developer experience is compromised because of service-side error messages."
  },
  {
    "id": "python-client-service-args",
    "category": "Yes:",
    "text": "DO support the common arguments for service operations:\n\n|Name|Description|Applies to|Notes|\n|-|-|-|-|\n|timeout|Timeout in seconds|All service methods|\n|headers|Custom headers to include in the service request|All requests|Headers are added to all requests made (directly or indirectly) by the method.|\n|client_request_id|Caller specified identification of the request.|Service operations for services that allow the client to send a client-generated correlation ID.|Examples of this include x-ms-client-request-id headers.|The client library must use this value if provided, or generate a unique value for each request when not specified.|\n|response_hook|callable that is called with (response, headers) for each operation.|All service methods|"
  },
  {
    "id": "python-client-splat-args",
    "category": "Yes:",
    "text": "DO accept a Mapping (dict-like) object in the same shape as a serialized model object for parameters.\n\n```python\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes:",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes:",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes:",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass Thing:\n\ndef do_something(thing: \"Thing\"):\n    ...\n\ndo_something(Thing(name='a', size=17)) # Works\ndo_something({'name': 'a', 'size', '17'}) # Does the same thing...\n```"
  },
  {
    "id": "python-client-flatten-args",
    "category": "Yes:",
    "text": "DO use \"flattened\" named arguments for update_ methods. May additionally take the whole model instance as a named parameter. If the caller passes both a model instance and individual key=value parameters, the explicit key=value parameters override whatever was specified in the model instance.\n\n```python\nclass Thing:\n\nclass Client:\n\nthing = Thing(name='hello', size=4711, description='This is a description...')\n\nclient.update_thing(thing=thing, size=4712) # Will send a request to the service to update the model's size to 4712\nthing.description = 'Updated'\nthing.size = -1\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Yes:",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Yes:",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes:",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes:",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes:",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes:",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes:",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes:",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes:",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes:",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes:",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes:",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes:",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes:",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes:",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes:",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes:",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes:",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes:",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes:",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes:",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes:",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes:",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes:",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes:",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes:",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes:",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes:",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes:",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes:",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes:",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes:",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes:",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes:",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient.update_thing(name='hello', size=4713, thing=thing)\n```\n\nServices may require multiple requests to retrieve the complete set of items in large collections. This is generally done by the service returning a partial result, and in the response providing a token or link that the client can use to retrieve the next batch of responses in addition to the set of items.\n\nIn Azure SDK for Python cilent libraries, this is exposed to users through the ItemPaged protocol. The ItemPaged protocol optimizes for retrieving the full set of items rather than forcing users to deal with the underlying paging."
  },
  {
    "id": "python-response-paged-protocol",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return a value that implements the ItemPaged protocol for operations that return collections. The ItemPaged protocol allows the user to iterate through all items in a returned collection, and also provides a method that gives access to individual pages.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Will send a request to the service to update the model's size to 4713 and description to 'Updated'",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "List all things - paging happens transparently in the",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "List all things - paging happens transparently in the",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "List all things - paging happens transparently in the",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "List all things - paging happens transparently in the",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "List all things - paging happens transparently in the",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "List all things - paging happens transparently in the",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "List all things - paging happens transparently in the",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "List all things - paging happens transparently in the",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "List all things - paging happens transparently in the",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "List all things - paging happens transparently in the",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "List all things - paging happens transparently in the",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "List all things - paging happens transparently in the",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "List all things - paging happens transparently in the",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "List all things - paging happens transparently in the",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "List all things - paging happens transparently in the",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "List all things - paging happens transparently in the",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "List all things - paging happens transparently in the",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "List all things - paging happens transparently in the",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "List all things - paging happens transparently in the",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "List all things - paging happens transparently in the",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "List all things - paging happens transparently in the",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "List all things - paging happens transparently in the",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "List all things - paging happens transparently in the",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "List all things - paging happens transparently in the",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "List all things - paging happens transparently in the",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "List all things - paging happens transparently in the",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "List all things - paging happens transparently in the",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "List all things - paging happens transparently in the",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "List all things - paging happens transparently in the",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "List all things - paging happens transparently in the",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "List all things - paging happens transparently in the",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "List all things - paging happens transparently in the",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "List all things - paging happens transparently in the",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "List all things - paging happens transparently in the",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "List all things - paging happens transparently in the",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "List all things - paging happens transparently in the",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "List all things - paging happens transparently in the",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfor thing in client.list_things():\n    print(thing)\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "background.",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "background.",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "background.",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "background.",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "background.",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "background.",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "background.",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "background.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "background.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "background.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "background.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "background.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "background.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "background.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "background.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "background.",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "background.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "background.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "background.",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "background.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "background.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "background.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "background.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "background.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "background.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "background.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "background.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "background.",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "background.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "background.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "background.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "background.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "background.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "background.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "background.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "background.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "background.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "background.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "background.",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "background.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "background.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "background.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "background.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "background.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "background.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "background.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "background.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "background.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "background.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "background.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "background.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "background.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "background.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "background.",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "background.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "background.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "background.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "background.",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "background.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "background.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "background.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "background.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "background.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "background.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "background.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "background.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "background.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "background.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "background.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "background.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "background.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "background.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "background.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "background.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "background.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "background.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "background.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "background.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "background.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "background.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "background.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "background.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "background.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "background.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "background.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "background.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "background.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "background.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "background.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "background.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "background.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "background.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfor page_no, page in enumerate(client.list_things().by_page()):\n    print(page_no, page)\n```"
  },
  {
    "id": "python-response-paged-results",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY expose a results_per_page keyword-only parameter where supported by the service (e.g. an OData $top query parameter)."
  },
  {
    "id": "python-response-paged-continuation",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD NOT expose a continuation parameter in the list_ client method - this is supported in the by_page() function.\n\n```python\nclient = ExampleClient(...)\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "The protocol also allows you to list things by page...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "The protocol also allows you to list things by page...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "The protocol also allows you to list things by page...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfor thing in client.list_things(continuation_token='...'):\n    print(thing)\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No - don't pass in the continuation token directly to the method...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfor page in client.list_things().by_page(continuation_token='...'):\n    print(page)\n```"
  },
  {
    "id": "python-paged-non-server-paged-list",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO return a value that implements the ItemPaged protocol even if the service API currently do not support server driven paging. This allows server driven paging to be added to the service API without introducing breaking changes in the client library.\n\nService operations that take a long time (currently defined in the Microsoft REST API Guidelines as not completing in 0.5s in P99) to complete are modeled by services as long running operations.\n\nPython client libraries abstracts the long running operation using the Long running operation Poller protocol.\nIn cases where a service API is not explicitly implemented as a long-running operation, but the common usage pattern requires a customer to sleep or poll a status - it's likely that these API's should still be represented in the SDK using the Poller protocol."
  },
  {
    "id": "python-lro-poller",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO return an object that implements the Poller protocol for long running operations."
  },
  {
    "id": "python-lro-poller-begin-naming",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use a begin_ prefix for all long running operations."
  },
  {
    "id": "python-method-conditional-request",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO add a keyword-only match_condition parameter for service methods that support conditional requests. The parameter should support the azure.core.MatchConditions type defined in azure-core as input."
  },
  {
    "id": "python-method-conditional-request-etag",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO add a keyword-only etag parameter for service methods that support conditional requests. For service methods that take a model instance that has an etag property, the explicit etag value passed in overrides the value in the model instance.\n\n```python\nclass Thing:\n\nthing = client.get_thing('theName')\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes - provide a continuation_token to in the by_page method...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient.update_thing(thing, name='updatedName', match_condition=azure.core.MatchConditions.IfNotModified)\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Uses the etag from the retrieved thing instance....",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclient.update_thing(thing, name='updatedName2', match_condition=azure.core.MatchConditions.IfNotModified, etag='\"igotthisetagfromsomewhereelse\"')\n```\n\nMany services have resources with nested child (or sub) resources. For example, Azure Storage provides an account that contains zero or more containers, which in turn contains zero or more blobs."
  },
  {
    "id": "python-client-hierarchy",
    "category": "Uses the explicitly provided etag.",
    "text": "DO create a client type corresponding to each level in the hierarchy except for leaf resource types. You may omit creating a client type for leaf node resources."
  },
  {
    "id": "python-client-hier-creation",
    "category": "Uses the explicitly provided etag.",
    "text": "DO make it possible to directly create clients for each level in the hierarchy.  The constructor can be called directly or via the parent.\n\n```python\nclass ChildClient:\n    # Yes:\n    init(self, parent, name, credentials, **kwargs) ...\n\nclass ChildClient:\n    # Yes:\n    init(self, url, credentials, **kwargs) ...\n```"
  },
  {
    "id": "python-client-hier-vend",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child."
  },
  {
    "id": "python-client-hier-create",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide method create_<child>(...) that creates a child resource. The method should return a client for the newly created child resource."
  },
  {
    "id": "python-client-hier-delete",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD provide method delete_<child>(...) that deletes a child resource.\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Uses the explicitly provided etag.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Uses the explicitly provided etag.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Uses the explicitly provided etag.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Uses the explicitly provided etag.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Uses the explicitly provided etag.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Uses the explicitly provided etag.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Uses the explicitly provided etag.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Uses the explicitly provided etag.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Uses the explicitly provided etag.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Uses the explicitly provided etag.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Uses the explicitly provided etag.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Uses the explicitly provided etag.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Uses the explicitly provided etag.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Uses the explicitly provided etag.",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Uses the explicitly provided etag.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Uses the explicitly provided etag.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Uses the explicitly provided etag.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Uses the explicitly provided etag.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Uses the explicitly provided etag.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Uses the explicitly provided etag.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Uses the explicitly provided etag.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Uses the explicitly provided etag.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Uses the explicitly provided etag.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Uses the explicitly provided etag.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Uses the explicitly provided etag.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Uses the explicitly provided etag.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Uses the explicitly provided etag.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Uses the explicitly provided etag.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Uses the explicitly provided etag.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Uses the explicitly provided etag.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Uses the explicitly provided etag.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nClient libraries represent entities transferred to and from Azure services as model types. Certain types are used for round-trips to the service. They can be sent to the service (as an addition or update operation) and retrieved from the service (as a get operation). These should be named according to the type. For example, a ConfigurationSetting in App Configuration, or a VirtualMachine on for Azure Resource Manager.\n\nData within the model type can generally be split into two parts - data used to support one of the champion scenarios for the service, and less important data. Given a type Foo, the less important details can be gathered in a type called FooDetails and attached to Foo as the details attribute."
  },
  {
    "id": "python-models-input-dict",
    "category": "Supporting types",
    "text": "DO support dicts as alternative inputs to model types."
  },
  {
    "id": "python-models-input-constructor",
    "category": "Supporting types",
    "text": "DO craft a constructor for models that are intended to be instantiated by a user (i.e. non-result types) with minimal required information and optional information as keyword-only arguments."
  },
  {
    "id": "python-models-generated",
    "category": "Supporting types",
    "text": "YOU MAY expose models from the generated layer by adding to the root __init__.py (and __all__) if they otherwise meet the guidelines."
  },
  {
    "id": "python-models-async",
    "category": "Supporting types",
    "text": "DO NOT duplicate models between the root and aio namespace.\n\nIn order to facilitate round-trip of responses (common in get resource -> conditionally modify resource -> set resource workflows), output model types should use the input model type (e.g. ConfigurationSetting) whenever possible. The ConfigurationSetting type should include both server generated (read-only) attributes even though they will be ignored when used as input to the set resource method.\n<model>Item for each item in an enumeration if the enumeration returns a partial schema for the model. For example, GetBlobs() return an enumeration of BlobItem, which contains the blob name and metadata, but not the content of the blob.\n<operation>Result for the result of an operation. The <operation> is tied to a specific service operation. If the same result can be used for multiple operations, use a suitable noun-verb phrase instead. For example, use UploadBlobResult for the result from UploadBlob, but ContainerChangeResult for results from the various methods that change a blob container."
  },
  {
    "id": "python-models-dict-result",
    "category": "Supporting types",
    "text": "DO use a simple Mapping (e.g. dict) rather than creating a <operation>Result class if the <operation>Result class is not used as an input parameter for other APIs.\n\nThe following table enumerates the various models you might create:\n\n|Type|Example|Usage|\n|-|-|\n||Secret|The full data for a resource|\n|Details|SecretDetails|Less important details about a resource. Attached to .details|\n|Item|SecretItem|A partial set of data returned for enumeration|\n|Result|AddSecretResult|A partial or different set of data for a single operation|\n|Result|SecretChangeResult|A partial or different set of data for multiple operations on a model|\n\n```python\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "Supporting types",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "Supporting types",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Supporting types",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Supporting types",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Supporting types",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Supporting types",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Supporting types",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Supporting types",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Supporting types",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Supporting types",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Supporting types",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Supporting types",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Supporting types",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Supporting types",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Supporting types",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Supporting types",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Supporting types",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Supporting types",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Supporting types",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Supporting types",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Supporting types",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Supporting types",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Supporting types",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Supporting types",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Supporting types",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Supporting types",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Supporting types",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Supporting types",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Supporting types",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Supporting types",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Supporting types",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Supporting types",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Supporting types",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Supporting types",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Supporting types",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Supporting types",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Supporting types",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Supporting types",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Supporting types",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Supporting types",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Supporting types",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Supporting types",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Supporting types",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Supporting types",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Supporting types",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Supporting types",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Supporting types",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Supporting types",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Supporting types",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Supporting types",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Supporting types",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Supporting types",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Supporting types",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Supporting types",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Supporting types",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Supporting types",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Supporting types",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Supporting types",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Supporting types",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Supporting types",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Supporting types",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Supporting types",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Supporting types",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Supporting types",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Supporting types",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Supporting types",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Supporting types",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Supporting types",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Supporting types",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Supporting types",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Supporting types",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ConfigurationSetting:\n    \"\"\"Model type representing a configuration setting\n\n```"
  },
  {
    "id": "python-models-enum-string",
    "category": "An example of a model type.",
    "text": "DO use extensible enumerations."
  },
  {
    "id": "python-models-enum-name-uppercase",
    "category": "An example of a model type.",
    "text": "DO use UPPERCASE names for enum names.\n\n```python\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "An example of a model type.",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "An example of a model type.",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "An example of a model type.",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "An example of a model type.",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "An example of a model type.",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "An example of a model type.",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "An example of a model type.",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "An example of a model type.",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "An example of a model type.",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "An example of a model type.",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "An example of a model type.",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "An example of a model type.",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "An example of a model type.",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "An example of a model type.",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "An example of a model type.",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "An example of a model type.",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "An example of a model type.",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "An example of a model type.",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "An example of a model type.",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "An example of a model type.",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "An example of a model type.",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "An example of a model type.",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "An example of a model type.",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "An example of a model type.",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "An example of a model type.",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "An example of a model type.",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "An example of a model type.",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "An example of a model type.",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "An example of a model type.",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "An example of a model type.",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "An example of a model type.",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "An example of a model type.",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "An example of a model type.",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "An example of a model type.",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "An example of a model type.",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "An example of a model type.",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "An example of a model type.",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "An example of a model type.",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "An example of a model type.",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "An example of a model type.",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "An example of a model type.",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "An example of a model type.",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "An example of a model type.",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "An example of a model type.",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "An example of a model type.",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "An example of a model type.",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "An example of a model type.",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "An example of a model type.",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "An example of a model type.",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "An example of a model type.",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "An example of a model type.",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "An example of a model type.",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "An example of a model type.",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "An example of a model type.",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "An example of a model type.",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "An example of a model type.",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "An example of a model type.",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "An example of a model type.",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "An example of a model type.",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "An example of a model type.",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "An example of a model type.",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "An example of a model type.",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "An example of a model type.",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "An example of a model type.",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "An example of a model type.",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "An example of a model type.",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "An example of a model type.",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "An example of a model type.",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "An example of a model type.",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "An example of a model type.",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "An example of a model type.",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "An example of a model type.",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "An example of a model type.",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Yes",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Yes",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Yes",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Yes",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Yes",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Yes",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Yes",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Yes",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Yes",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Yes",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Yes",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Yes",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Yes",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Yes",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Yes",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n```"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "No",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "No",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "No",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "No",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "No",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "No",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "No",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "No",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "No",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "No",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "No",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "No",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "No",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "No",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "No",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "No",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-errors-azure-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD prefer raising existing exception types from the azure-core package over creating new exception types."
  },
  {
    "id": "python-errors-use-standard-exceptions",
    "category": "Exceptions",
    "text": "DO NOT create new exception types when a built-in exception type will suffice."
  },
  {
    "id": "python-errors-new-exceptions",
    "category": "Exceptions",
    "text": "YOU SHOULD NOT create a new exception type unless the developer can handle the error programmatically.  Specialized exception types related to service operation failures should be based on existing exception types from the azure-core package.\n\nFor higher-level methods that use multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced."
  },
  {
    "id": "python-errors-rich-info",
    "category": "Exceptions",
    "text": "DO include any service-specific error information in the exception.  Service-specific error information must be available in service-specific properties or fields."
  },
  {
    "id": "python-errors-documentation",
    "category": "Exceptions",
    "text": "DO document the errors that are produced by each method. Don't document commonly thrown errors that wouldn't normally be documented in Python (e.g. ValueError, TypeError, RuntimeError etc.)"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Exceptions",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Exceptions",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Exceptions",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Exceptions",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Exceptions",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Exceptions",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Exceptions",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Exceptions",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Exceptions",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Exceptions",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Exceptions",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Exceptions",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Exceptions",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Exceptions",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Exceptions",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Exceptions",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Exceptions",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Exceptions",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Exceptions",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Exceptions",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Exceptions",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Exceptions",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Exceptions",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Exceptions",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Exceptions",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Exceptions",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Exceptions",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Exceptions",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Exceptions",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Exceptions",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Exceptions",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Exceptions",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Exceptions",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Exceptions",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Exceptions",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Exceptions",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Exceptions",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Exceptions",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Exceptions",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Exceptions",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Exceptions",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Exceptions",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Exceptions",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Exceptions",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Exceptions",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Exceptions",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Exceptions",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Exceptions",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Exceptions",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Exceptions",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Exceptions",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Exceptions",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Exceptions",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Exceptions",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Exceptions",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Exceptions",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Exceptions",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Exceptions",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Exceptions",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Exceptions",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Exceptions",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Exceptions",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Exceptions",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Exceptions",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Exceptions",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-auth-credential-azure-core",
    "category": "Authentication",
    "text": "DO use the credentials classes in azure-core whenever possible."
  },
  {
    "id": "python-auth-policy-azure-core",
    "category": "Authentication",
    "text": "DO use authentication policy implementations in azure-core whenever possible."
  },
  {
    "id": "python-auth-service-credentials",
    "category": "Authentication",
    "text": "{% include requirement/MAY  id=\"python-auth-service-credentials\" %} add additional credential types if required by the service. Contact the [Architecture board] for guidance if you believe you have need to do so."
  },
  {
    "id": "python-auth-service-support",
    "category": "Authentication",
    "text": "DO support all authentication methods that the service supports.\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Authentication",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Authentication",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Authentication",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Authentication",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Authentication",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Authentication",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Authentication",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Authentication",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Authentication",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Authentication",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Authentication",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Authentication",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Authentication",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Authentication",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Authentication",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Authentication",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Authentication",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Authentication",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Authentication",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Authentication",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Authentication",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Authentication",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Authentication",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Authentication",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Authentication",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Authentication",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Authentication",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Authentication",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Authentication",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Authentication",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Authentication",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Authentication",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Authentication",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Authentication",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Authentication",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Authentication",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Authentication",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Authentication",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Authentication",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Authentication",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Authentication",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Authentication",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Authentication",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Authentication",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Authentication",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Authentication",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Authentication",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Authentication",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Authentication",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Authentication",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Authentication",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Authentication",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Authentication",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Authentication",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Authentication",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Authentication",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Authentication",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Authentication",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Authentication",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Authentication",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Authentication",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Authentication",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nIn the guidelines below, the term \"namespace\" is used to denote a python package or module (i.e. something that you would import in your code). The term \"distribution package\" is used to describe the artifact you publish to and install from your package manager (i.e. something that you would pip install)."
  },
  {
    "id": "python-namespaces-prefix",
    "category": "Namespaces",
    "text": "DO implement your library as a sub-package of the azure root namespace."
  },
  {
    "id": "python-namespaces-naming",
    "category": "Namespaces",
    "text": "DO pick a package name that allows the consumer to tie the namespace to the service being used. As a default, use the compressed service name at the end of the namespace. The namespace does NOT change when the branding of the product changes. Avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces. It may further be shortened if the shortened version is well known in the community. For example, \u201cAzure Media Analytics\u201d would have a compressed service name of mediaanalytics, and \u201cAzure Service Bus\u201d would become servicebus.  Separate words using an underscore if necessary. For example, mediaanalytics could be separated into media_analytics"
  },
  {
    "id": "python-namespaces-grouping",
    "category": "Namespaces",
    "text": "YOU MAY include a group name segment in your namespace (for example, azure.<group>.<servicename>) if your service or family of services have common behavior (for example, shared authentication types)."
  },
  {
    "id": "python-namespaces-grouping-dont-introduce-new-packages",
    "category": "Namespaces",
    "text": "DO avoid introducing new distribution packages that only differ in name. For existing packages, this means that you should not change the name of the package just to introduce a group name.\n\nIf you want to use a group name segment, use one of the following groups:\n\n{% include tables/data_namespaces.md %}"
  },
  {
    "id": "python-namespaces-mgmt",
    "category": "Namespaces",
    "text": "DO place management (Azure Resource Manager) APIs in the mgmt group. Use the grouping azure.mgmt.<servicename> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only."
  },
  {
    "id": "python-namespaces-register",
    "category": "Namespaces",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an [issue] to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "python-namespaces-async",
    "category": "Namespaces",
    "text": "DO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Namespaces",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Namespaces",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Namespaces",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Namespaces",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Namespaces",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Namespaces",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Namespaces",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Namespaces",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Namespaces",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Namespaces",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Namespaces",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Namespaces",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Namespaces",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Namespaces",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Namespaces",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Namespaces",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Namespaces",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Namespaces",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Namespaces",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Namespaces",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Namespaces",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Namespaces",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Namespaces",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Namespaces",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Namespaces",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Namespaces",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Namespaces",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Namespaces",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Namespaces",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Namespaces",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Namespaces",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Namespaces",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Namespaces",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Namespaces",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Namespaces",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Namespaces",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Namespaces",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Namespaces",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Namespaces",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Namespaces",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Namespaces",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Namespaces",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Namespaces",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Namespaces",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Namespaces",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Namespaces",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Namespaces",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Namespaces",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Namespaces",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Namespaces",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Namespaces",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Namespaces",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Namespaces",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Namespaces",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfrom azure.exampleservice.aio import ExampleServiceClient\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Yes:",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Yes:",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Yes:",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes:",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes:",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes:",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes:",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes:",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes:",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes:",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes:",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes:",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes:",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes:",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes:",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes:",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes:",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes:",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes:",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes:",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes:",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes:",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes:",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes:",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes:",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes:",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes:",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes:",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes:",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes:",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes:",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes:",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes:",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes:",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes:",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes:",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes:",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes:",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes:",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes:",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes:",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes:",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes:",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes:",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes:",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes:",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes:",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes:",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes:",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes:",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes:",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes:",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes:",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes:",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes:",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nfrom azure.exampleservice import AsyncExampleServiceClient\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No: Wrong namespace, wrong client name...",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods."
  },
  {
    "id": "python-client-sync-async",
    "category": "Async support",
    "text": "DO provide both sync and async versions of your APIs"
  },
  {
    "id": "python-client-async-keywords",
    "category": "Async support",
    "text": "DO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine syntax."
  },
  {
    "id": "python-client-separate-sync-async",
    "category": "Async support",
    "text": "DO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Async support",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Async support",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Async support",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Async support",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Async support",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Async support",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Async support",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Async support",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Async support",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Async support",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Async support",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Async support",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Async support",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Async support",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Async support",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Async support",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Async support",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Async support",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Async support",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Async support",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Async support",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Async support",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Async support",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Async support",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Async support",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Async support",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Async support",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Async support",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Async support",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Async support",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Async support",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Async support",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Async support",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Async support",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Async support",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Async support",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Async support",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Async support",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Async support",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Async support",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Async support",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Async support",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Async support",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Async support",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Async support",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Async support",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Async support",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Async support",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Async support",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Async support",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Async support",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Async support",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Async support",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "Yes",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "Yes",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "Yes",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "Yes",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "Yes",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "Yes",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Yes",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Yes",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Yes",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Yes",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Yes",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Yes",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Yes",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Yes",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Yes",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Yes",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Yes",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Yes",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Yes",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Yes",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Yes",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Yes",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Yes",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Yes",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Yes",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Yes",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Yes",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Yes",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Yes",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Yes",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Yes",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Yes",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Yes",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Yes",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Yes",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Yes",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Yes",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Yes",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Yes",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Yes",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Yes",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Yes",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Yes",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Yes",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Yes",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Yes",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Yes",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Yes",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Yes",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Yes",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Yes",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Yes",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Yes",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example.aio",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example.aio",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example.aio",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example.aio",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example.aio",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example.aio",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example.aio",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example.aio",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example.aio",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example.aio",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example.aio",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example.aio",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example.aio",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example.aio",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example.aio",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example.aio",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example.aio",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example.aio",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example.aio",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example.aio",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example.aio",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example.aio",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example.aio",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example.aio",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example.aio",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example.aio",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example.aio",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example.aio",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example.aio",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example.aio",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example.aio",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example.aio",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example.aio",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example.aio",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example.aio",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example.aio",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example.aio",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example.aio",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example.aio",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example.aio",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example.aio",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example.aio",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example.aio",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example.aio",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example.aio",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example.aio",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example.aio",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example.aio",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example.aio",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example.aio",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example.aio",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example.aio",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example.aio",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example.aio",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "No",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "No",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "No",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "No",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "No",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "No",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "No",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "No",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "No",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "No",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "No",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "No",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "No",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "No",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "No",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "No",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "No",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "No",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "No",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "No",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "No",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "No",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "No",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "No",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "No",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "No",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "No",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "No",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "No",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "No",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "No",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "No",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "No",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "No",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "No",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "No",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "No",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "No",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "No",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "No",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "No",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "No",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "No",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "No",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "No",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "No",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "No",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "No",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "No",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "No",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "No",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "No",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "No",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "No",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n```"
  },
  {
    "id": "python-client-same-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|"
  },
  {
    "id": "python-client-namespace-sync",
    "category": "In module azure.example",
    "text": "DO use the same namespace for the synchronous client as the synchronous version of the package with .aio appended.\n\nExample:\n\n```python\nfrom azure.storage.blob import BlobServiceClient # Sync client\n\nfrom azure.storage.blob.aio import BlobServiceClient # Async client\n```"
  },
  {
    "id": "python-client-separate-async-pkg",
    "category": "In module azure.example",
    "text": "YOU SHOULD ship a separate package for async support if the async version requires additional dependencies."
  },
  {
    "id": "python-client-same-pkg-name-sync-async",
    "category": "In module azure.example",
    "text": "DO use the same name for the asynchronous version of the package as the synchronous version of the package with -aio appended."
  },
  {
    "id": "python-client-async-http-stack",
    "category": "In module azure.example",
    "text": "DO use aiohttp as the default HTTP stack for async operations. Use azure.core.pipeline.transport.AioHttpTransport as the default transport type for the async client."
  },
  {
    "id": "python-packaging-name",
    "category": "In module azure.example",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "In module azure.example",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "In module azure.example",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "In module azure.example",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "In module azure.example",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "In module azure.example",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "In module azure.example",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "In module azure.example",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "In module azure.example",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "In module azure.example",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "In module azure.example",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "In module azure.example",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "In module azure.example",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "In module azure.example",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "In module azure.example",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "In module azure.example",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "In module azure.example",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "In module azure.example",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "In module azure.example",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "In module azure.example",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "In module azure.example",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "In module azure.example",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "In module azure.example",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "In module azure.example",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "In module azure.example",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "In module azure.example",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "In module azure.example",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "In module azure.example",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "In module azure.example",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "In module azure.example",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "In module azure.example",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "In module azure.example",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "In module azure.example",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "In module azure.example",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "In module azure.example",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "In module azure.example",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "In module azure.example",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "In module azure.example",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "In module azure.example",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "In module azure.example",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "In module azure.example",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "In module azure.example",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "In module azure.example",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "In module azure.example",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "In module azure.example",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "In module azure.example",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "In module azure.example",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Azure SDK distribution packages",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Azure SDK distribution packages",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Azure SDK distribution packages",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Azure SDK distribution packages",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Azure SDK distribution packages",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Azure SDK distribution packages",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Azure SDK distribution packages",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Azure SDK distribution packages",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Azure SDK distribution packages",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Azure SDK distribution packages",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Azure SDK distribution packages",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Azure SDK distribution packages",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Azure SDK distribution packages",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Azure SDK distribution packages",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Azure SDK distribution packages",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Azure SDK distribution packages",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Azure SDK distribution packages",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Azure SDK distribution packages",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Azure SDK distribution packages",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Azure SDK distribution packages",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Azure SDK distribution packages",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Azure SDK distribution packages",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Azure SDK distribution packages",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Azure SDK distribution packages",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Azure SDK distribution packages",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Azure SDK distribution packages",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Azure SDK distribution packages",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Azure SDK distribution packages",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Azure SDK distribution packages",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Azure SDK distribution packages",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Azure SDK distribution packages",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-packaging-name",
    "category": "Packaging",
    "text": "DO name your package after the namespace of your main client class. For example, if your main client class is in the azure.data.tables namespace, your package name should be azure-data-tables."
  },
  {
    "id": "python-packaging-name-allowed-chars",
    "category": "Packaging",
    "text": "DO use all lowercase in your package name with a dash (-) as a separator."
  },
  {
    "id": "python-packaging-name-disallowed-chars",
    "category": "Packaging",
    "text": "DO NOT use underscore (_) or period (.) in your package name. If your namespace includes underscores, replace them with dash (-) in the distribution package name."
  },
  {
    "id": "python-packaging-follow-repo-rules",
    "category": "Packaging",
    "text": "DO follow the specific package guidance from the azure-sdk-packaging wiki"
  },
  {
    "id": "python-packaging-follow-python-rules",
    "category": "Packaging",
    "text": "DO follow the namespace package recommendations for Python 3.x for packages that only need to target 3.x."
  },
  {
    "id": "python-general-supply-sdist",
    "category": "Packaging",
    "text": "DO provide both source distributions (sdist) and wheels."
  },
  {
    "id": "python-general-pypi",
    "category": "Packaging",
    "text": "DO publish both source distributions (sdist) and wheels to PyPI."
  },
  {
    "id": "python-general-wheel-behavior",
    "category": "Packaging",
    "text": "DO test correct behavior for both CPython and PyPy for pure and universal Python wheels."
  },
  {
    "id": "python-packaging-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-nspkg for Python 2.x."
  },
  {
    "id": "python-packaging-group-nspkg",
    "category": "Packaging",
    "text": "DO depend on azure-<group>-nspkg for Python 2.x if you are using namespace grouping."
  },
  {
    "id": "python-packaging-init",
    "category": "Packaging",
    "text": "DO include __init__.py for the namespace(s) in sdists\n\nThere are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models."
  },
  {
    "id": "python-commonlib-approval",
    "category": "Packaging",
    "text": "DO gain [Architecture Board] approval prior to implementing a common library."
  },
  {
    "id": "python-commonlib-minimize-code",
    "category": "Packaging",
    "text": "DO minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.\n\nA common library will only be approved if:\nThe consumer of the non-shared library will consume the objects within the common library directly, AND\nThe information will be shared between multiple client libraries\n\nLet's take two examples:\n\nImplementing two Cognitive Services client libraries, we find that they both rely on the same business logic. This is a candidate for choosing a common library.\n\n\nTwo Cognitive Services client libraries have models (data classes) that are the same in shape, but has no or minimal logic associated with them. This is not a good candidate for a shared library. Instead, implement two separate classes.\n"
  },
  {
    "id": "python-versioning-semver",
    "category": "Packaging",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Packaging",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Packaging",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Packaging",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Packaging",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Packaging",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Packaging",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Packaging",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Packaging",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Packaging",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Packaging",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Packaging",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Packaging",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Packaging",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Packaging",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Packaging",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Packaging",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Packaging",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Packaging",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Packaging",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Packaging",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Packaging",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Packaging",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Packaging",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Packaging",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Packaging",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Packaging",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Packaging",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Packaging",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Packaging",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Packaging",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Packaging",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Packaging",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Packaging",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Packaging",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Packaging",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-versioning-semver",
    "category": "Package Versioning",
    "text": "DO use semantic versioning for your package."
  },
  {
    "id": "python-versioning-beta",
    "category": "Package Versioning",
    "text": "DO use the bN pre-release segment for beta releases.\n\nDon't use pre-release segments other than the ones defined in PEP440 (aN, bN, rcN). Build tools, publication tools, and index servers may not sort the versions correctly."
  },
  {
    "id": "python-versioning-changes",
    "category": "Package Versioning",
    "text": "DO change the version number if anything changes in the library."
  },
  {
    "id": "python-versioning-patch",
    "category": "Package Versioning",
    "text": "DO increment the patch version if only bug fixes are added to the package."
  },
  {
    "id": "python-verioning-minor",
    "category": "Package Versioning",
    "text": "DO increment the minor version if any new functionality is added to the package."
  },
  {
    "id": "python-versioning-apiversion",
    "category": "Package Versioning",
    "text": "DO increment (at least) the minor version if the default REST API version is changed, even if there's no public API change to the library."
  },
  {
    "id": "python-versioning-api-major",
    "category": "Package Versioning",
    "text": "DO NOT increment the major version for a new REST API version unless it requires breaking API changes in the python library itself."
  },
  {
    "id": "python-versioning-major",
    "category": "Package Versioning",
    "text": "DO increment the major version if there are breaking changes in the package. Breaking changes require prior approval from the [Architecture Board]."
  },
  {
    "id": "python-versioning-major-cross-languages",
    "category": "Package Versioning",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nThe bar to make a breaking change is extremely high for stable client libraries.  We may create a new package with a different name to avoid diamond dependency issues."
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Package Versioning",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Package Versioning",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Package Versioning",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Package Versioning",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Package Versioning",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Package Versioning",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Package Versioning",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Package Versioning",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Package Versioning",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Package Versioning",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Package Versioning",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Package Versioning",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Package Versioning",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Package Versioning",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Package Versioning",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Package Versioning",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Package Versioning",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Package Versioning",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Package Versioning",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Package Versioning",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Package Versioning",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Package Versioning",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Package Versioning",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Package Versioning",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Package Versioning",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Package Versioning",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-dependencies-approved-list",
    "category": "Dependencies",
    "text": "DO only pick external dependencies from the following list of well known packages for shared functionality:\n\n{% include_relative approved_dependencies.md %}"
  },
  {
    "id": "python-dependencies-external",
    "category": "Dependencies",
    "text": "DO NOT use external dependencies outside the list of well known dependencies. To get a new dependency added, contact the [Architecture Board]."
  },
  {
    "id": "python-dependencies-vendor",
    "category": "Dependencies",
    "text": "DO NOT vendor dependencies unless approved by the [Architecture Board].\n\nWhen you vendor a dependency in Python, you include the source from another package as if it was part of your package."
  },
  {
    "id": "python-dependencies-pin-version",
    "category": "Dependencies",
    "text": "DO NOT pin a specific version of a dependency unless that is the only way to work around a bug in said dependencies versioning scheme.\n\nOnly applications are expected to pin exact dependencies. Libraries are not. A library should use a compatible release identifier for the dependency."
  },
  {
    "id": "python-native-approval",
    "category": "Dependencies",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Dependencies",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Dependencies",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Dependencies",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Dependencies",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Dependencies",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Dependencies",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Dependencies",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Dependencies",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Dependencies",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Dependencies",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Dependencies",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Dependencies",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Dependencies",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Dependencies",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Dependencies",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Dependencies",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Dependencies",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Dependencies",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Dependencies",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Dependencies",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Dependencies",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-native-approval",
    "category": "Binary extensions (native code)",
    "text": "DO seek approval by the [Architecture Board] before implementing a binary extension."
  },
  {
    "id": "python-native-plat-support",
    "category": "Binary extensions (native code)",
    "text": "DO support Windows, Linux (manylinux - see PEP513, PEP571), and MacOS.  Support the earliest possible manylinux to maximize your reach."
  },
  {
    "id": "python-native-arch-support",
    "category": "Binary extensions (native code)",
    "text": "DO support both x86 and x64 architectures."
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Binary extensions (native code)",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Binary extensions (native code)",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Binary extensions (native code)",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Binary extensions (native code)",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Binary extensions (native code)",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Binary extensions (native code)",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Binary extensions (native code)",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Binary extensions (native code)",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Binary extensions (native code)",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Binary extensions (native code)",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Binary extensions (native code)",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Binary extensions (native code)",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Binary extensions (native code)",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Binary extensions (native code)",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Binary extensions (native code)",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Binary extensions (native code)",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Binary extensions (native code)",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  },
  {
    "id": "python-docstrings-pydocs",
    "category": "Docstrings",
    "text": "DO follow the documentation guidelines unless explicitly overridden in this document."
  },
  {
    "id": "python-docstrings-all",
    "category": "Docstrings",
    "text": "DO provide docstrings for all public modules, types, constants and functions."
  },
  {
    "id": "python-docstrings-kwargs",
    "category": "Docstrings",
    "text": "DO document any **kwargs directly consumed by a method. You may refer to the signature of a called method if the **kwargs are passed through.\n\nExample:\n```python\ndef request(method, url, headers, **kwargs): ...\n\ndef get(args, kwargs):\n    \"Calls request with the method \"GET\" and forwards all other arguments.\"\n    return request(\"GET\", args, **kwargs)\n```"
  },
  {
    "id": "python-docstrings-exceptions",
    "category": "Docstrings",
    "text": "DO document exceptions that may be raised explicitly in the method and any exceptions raised by the called method."
  },
  {
    "id": "python-snippets-include",
    "category": "Docstrings",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-snippets-build",
    "category": "Docstrings",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "python-snippets-docstrings",
    "category": "Docstrings",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings. Each sample should be a valid pytest.\n\nUse the literalinclude directive in Python docstrings to instruct Sphinx to [ingest the snippets automatically][1]."
  },
  {
    "id": "python-snippets-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Docstrings",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Docstrings",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Docstrings",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Docstrings",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Docstrings",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Docstrings",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Docstrings",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Docstrings",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Docstrings",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Docstrings",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Docstrings",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Docstrings",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Repository Guidelines",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Repository Guidelines",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Repository Guidelines",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Repository Guidelines",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Repository Guidelines",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Repository Guidelines",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Repository Guidelines",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Repository Guidelines",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Repository Guidelines",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Repository Guidelines",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Repository Guidelines",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Repository Guidelines",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/appconfiguration/azure-appconfiguration/README.md])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "python-docs-content-dev",
    "category": "Documentation style",
    "text": "DO include your service's content developer in the adparch review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "python-docs-contributor-guide",
    "category": "Documentation style",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "python-docs-style-guide",
    "category": "Documentation style",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "python-docs-into-silence",
    "category": "Documentation style",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Documentation style",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Documentation style",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Documentation style",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Documentation style",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Documentation style",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Documentation style",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Documentation style",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Documentation style",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}\n\nCode samples are small applications that demonstrate a certain feature that is relevant to the client library. Samples allow developers to quickly understand the full usage requirements of your client library. Code samples shouldn't be any more complex than they needed to demonstrate the feature. Don't write full applications. Samples should have a high signal to noise ratio between useful code and boilerplate code for non-related reasons."
  },
  {
    "id": "python-samples-include-them",
    "category": "Samples",
    "text": "DO include code samples alongside your library's code within the repository. The samples should clearly and succinctly demonstrate the code most developers need to write with your library. Include samples for all common operations. Pay attention to operations that are complex or might be difficult for new users of your library. Include samples for the champion scenarios you've identified for the library."
  },
  {
    "id": "python-samples-location",
    "category": "Samples",
    "text": "DO place code samples within the /samples directory within the client library root directory. The samples will be packaged into the resulting distribution package."
  },
  {
    "id": "python-samples-runnable",
    "category": "Samples",
    "text": "DO ensure that each sample file is runnable."
  },
  {
    "id": "python-samples-coding-style",
    "category": "Samples",
    "text": "DO avoid using features newer than the Python 3 baseline support. The current supported Python version is 3.7."
  },
  {
    "id": "python-samples-grafting",
    "category": "Samples",
    "text": "DO ensure that code samples can be easily grafted from the documentation into a users own application. For example, don't rely on variable declarations in other samples."
  },
  {
    "id": "python-samples-readability",
    "category": "Samples",
    "text": "DO write code samples for ease of reading and comprehension over code compactness and efficiency."
  },
  {
    "id": "python-samples-platform-support",
    "category": "Samples",
    "text": "DO ensure that samples can run in Windows, macOS, and Linux development environments."
  },
  {
    "id": "python-snippets-no-combinations",
    "category": "Samples",
    "text": "DO NOT combine multiple scenarios in a code sample unless it's required for demonstrating the type or member. For example, a Cosmos DB code sample doesn't include both account and container creation operations. Create a sample for account creation, and another sample for container creation.\n\nCombined scenarios require knowledge of additional operations that might be outside their current focus. The developer must first understand the code surrounding the scenario they're working on, and can't copy and paste the code sample into their project.\n\n{% include refs.md %}\n{% include_relative refs.md %}"
  }
]